#!/usr/bin/env node
/**
 * bkit Common Library (v1.4.3)
 * Cross-platform utility functions for bkit hooks
 * Supports: Claude Code, Gemini CLI
 *
 * Converted from: lib/common.sh
 * Platform: Windows, macOS, Linux
 * Dependencies: Node.js only (no external tools like jq, bash)
 *
 * v1.4.3 Changes:
 * - Added xmlSafeOutput() for Gemini CLI v0.27+ XML wrapping compatibility (FR-1.1)
 * - Applied xmlSafeOutput() to outputAllow() and outputBlock() for safe context output
 *
 * v1.4.0 Changes:
 * - Added Debug Logging system (debugLog, getDebugLogPath)
 * - Added PDCA Status Management (updatePdcaStatus, getPdcaStatusFull, etc.)
 * - Added extractFeatureFromContext for multi-source feature detection
 */

const fs = require('fs');
const path = require('path');

// ============================================================
// Environment & Configuration (v1.4.0 - Dual Platform Support)
// ============================================================

/**
 * Detect current platform (Claude Code or Gemini CLI)
 * @returns {'claude' | 'gemini' | 'unknown'}
 */
function detectPlatform() {
  if (process.env.GEMINI_PROJECT_DIR || process.env.GEMINI_SESSION_ID || process.env.GEMINI_EXTENSION_PATH) {
    return 'gemini';
  }
  if (process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR) {
    return 'claude';
  }
  return 'unknown';
}

const BKIT_PLATFORM = process.env.BKIT_PLATFORM || detectPlatform();

// Cross-platform environment variables with fallback chain
const PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT
  || process.env.GEMINI_EXTENSION_PATH
  || path.resolve(__dirname, '..');

const PROJECT_DIR = process.env.CLAUDE_PROJECT_DIR
  || process.env.GEMINI_PROJECT_DIR
  || process.cwd();

// Unified project directory alias
const BKIT_PROJECT_DIR = PROJECT_DIR;

// ============================================================
// v1.4.0 P4: Performance Optimization - Caching System
// ============================================================

/**
 * In-memory cache for frequently accessed data
 * TTL-based invalidation for config files and status
 */
const _cache = {
  data: new Map(),
  timestamps: new Map(),
  defaultTTL: 5000,  // 5 seconds default TTL

  /**
   * Get cached value if not expired
   * @param {string} key - Cache key
   * @param {number} ttl - Time-to-live in ms (default: 5000)
   * @returns {any|null} Cached value or null if expired/missing
   */
  get(key, ttl = this.defaultTTL) {
    const timestamp = this.timestamps.get(key);
    if (!timestamp) return null;

    if (Date.now() - timestamp > ttl) {
      this.data.delete(key);
      this.timestamps.delete(key);
      return null;
    }
    return this.data.get(key);
  },

  /**
   * Set cache value with timestamp
   * @param {string} key - Cache key
   * @param {any} value - Value to cache
   */
  set(key, value) {
    this.data.set(key, value);
    this.timestamps.set(key, Date.now());
  },

  /**
   * Invalidate specific cache key or all keys matching pattern
   * @param {string|RegExp} keyOrPattern - Key or pattern to invalidate
   */
  invalidate(keyOrPattern) {
    if (typeof keyOrPattern === 'string') {
      this.data.delete(keyOrPattern);
      this.timestamps.delete(keyOrPattern);
    } else {
      // RegExp pattern
      for (const key of this.data.keys()) {
        if (keyOrPattern.test(key)) {
          this.data.delete(key);
          this.timestamps.delete(key);
        }
      }
    }
  },

  /**
   * Clear all cache
   */
  clear() {
    this.data.clear();
    this.timestamps.clear();
  }
};

// Default patterns (configurable via bkit.config.json)
const DEFAULT_EXCLUDE_PATTERNS = [
  'node_modules', '.git', 'dist', 'build', '.next',
  '__pycache__', '.venv', 'venv', 'coverage',
  '.pytest_cache', 'target', '.cargo', 'vendor'
];

const DEFAULT_FEATURE_PATTERNS = [
  'features', 'modules', 'packages', 'apps', 'services', 'domains'
];

// Language Tier System (v1.2.1)
const TIER_EXTENSIONS = {
  1: ['py', 'pyx', 'pyi', 'ts', 'tsx', 'js', 'jsx', 'mjs', 'cjs'],
  2: ['go', 'rs', 'dart', 'astro', 'vue', 'svelte', 'mdx'],
  3: ['java', 'kt', 'kts', 'swift', 'c', 'cpp', 'cc', 'h', 'hpp', 'sh', 'bash'],
  4: ['php', 'rb', 'erb', 'cs', 'scala', 'ex', 'exs'],
  experimental: ['mojo', 'zig', 'v']
};

// ============================================================
// 1. Configuration Management
// ============================================================

let _configCache = null;

/**
 * Load bkit.config.json
 * @returns {Object} Configuration object or empty object
 */
function loadConfig() {
  if (_configCache !== null) return _configCache;

  const configPath = path.join(PROJECT_DIR, 'bkit.config.json');
  try {
    if (fs.existsSync(configPath)) {
      _configCache = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      return _configCache;
    }
  } catch (e) { /* ignore */ }
  _configCache = {};
  return _configCache;
}

/**
 * Get configuration value by path
 * @param {string} keyPath - Dot-separated path (e.g., "pdca.thresholds.quickFix")
 * @param {*} defaultValue - Default value if not found
 * @returns {*} Configuration value or default
 */
function getConfig(keyPath, defaultValue = null) {
  const config = loadConfig();
  const keys = keyPath.replace(/^\./, '').split('.');
  let value = config;

  for (const key of keys) {
    if (value && typeof value === 'object' && key in value) {
      value = value[key];
    } else {
      return defaultValue;
    }
  }
  return value ?? defaultValue;
}

/**
 * Get configuration array as space-separated string (for compatibility)
 * @param {string} keyPath - Configuration path
 * @param {string} defaultValue - Default space-separated string
 * @returns {string} Space-separated values
 */
function getConfigArray(keyPath, defaultValue = '') {
  const value = getConfig(keyPath, null);
  if (Array.isArray(value)) {
    return value.join(' ');
  }
  return defaultValue;
}

// ============================================================
// 2. File Detection Functions
// ============================================================

/**
 * Check if file is a source code file
 * @param {string} filePath - File path to check
 * @returns {boolean} True if source file
 */
function isSourceFile(filePath) {
  if (!filePath) return false;

  // Exclude patterns
  const excludePatterns = getConfig('excludePatterns', DEFAULT_EXCLUDE_PATTERNS);
  for (const pattern of excludePatterns) {
    if (filePath.includes(pattern)) return false;
  }

  // Exclude documentation and config files
  const excludeExtensions = ['.md', '.json', '.yaml', '.yml', '.lock', '.txt', '.log'];
  const ext = path.extname(filePath).toLowerCase();
  if (excludeExtensions.includes(ext)) return false;

  // Exclude hidden files
  const basename = path.basename(filePath);
  if (basename.startsWith('.')) return false;

  return isCodeFile(filePath);
}

/**
 * Check if file has recognized code extension
 * @param {string} filePath - File path to check
 * @returns {boolean} True if code file
 */
function isCodeFile(filePath) {
  const ext = path.extname(filePath).slice(1).toLowerCase();
  if (!ext) return false;

  for (const tier of Object.values(TIER_EXTENSIONS)) {
    if (tier.includes(ext)) return true;
  }
  return false;
}

/**
 * Check if file is a UI component file
 * @param {string} filePath - File path
 * @returns {boolean} True if UI file
 */
function isUiFile(filePath) {
  const ext = path.extname(filePath).slice(1).toLowerCase();
  return ['tsx', 'jsx', 'vue', 'svelte', 'astro'].includes(ext);
}

/**
 * Check if file is an environment file
 * @param {string} filePath - File path
 * @returns {boolean} True if env file
 */
function isEnvFile(filePath) {
  const basename = path.basename(filePath);
  return basename.includes('.env') || basename.startsWith('.env');
}

// ============================================================
// 3. Tier Detection Functions
// ============================================================

/**
 * Get language tier for file
 * @param {string} filePath - File path
 * @returns {string} Tier: "1"|"2"|"3"|"4"|"experimental"|"unknown"
 */
function getLanguageTier(filePath) {
  const ext = path.extname(filePath).slice(1).toLowerCase();

  for (const [tier, extensions] of Object.entries(TIER_EXTENSIONS)) {
    if (extensions.includes(ext)) return String(tier);
  }
  return 'unknown';
}

/**
 * Get tier description
 * @param {string} tier - Tier number or name
 * @returns {string} Description
 */
function getTierDescription(tier) {
  const descriptions = {
    '1': 'AI-Native Essential',
    '2': 'Mainstream Recommended',
    '3': 'Domain Specific',
    '4': 'Legacy/Niche',
    'experimental': 'Experimental'
  };
  return descriptions[tier] || 'Unknown';
}

/**
 * Get PDCA guidance for tier
 * @param {string} tier - Tier
 * @returns {string} Guidance message
 */
function getTierPdcaGuidance(tier) {
  const guidance = {
    '1': 'Tier 1 (AI-Native): Full PDCA support. Vibe coding optimized.',
    '2': 'Tier 2 (Mainstream): Good PDCA support. Most features available.',
    '3': 'Tier 3 (Domain): Basic PDCA support. Some limitations may apply.',
    '4': 'Tier 4 (Legacy): Limited PDCA support. Consider migration.',
    'experimental': 'Experimental: PDCA support varies. Use with caution.'
  };
  return guidance[tier] || '';
}

// Convenience tier check functions
const isTier1 = (filePath) => getLanguageTier(filePath) === '1';
const isTier2 = (filePath) => getLanguageTier(filePath) === '2';
const isTier3 = (filePath) => getLanguageTier(filePath) === '3';
const isTier4 = (filePath) => getLanguageTier(filePath) === '4';
const isExperimentalTier = (filePath) => getLanguageTier(filePath) === 'experimental';

// ============================================================
// 4. Feature Detection
// ============================================================

/**
 * Extract feature name from file path
 * @param {string} filePath - File path
 * @returns {string} Feature name or empty string
 */
function extractFeature(filePath) {
  if (!filePath) return '';

  const featurePatterns = getConfig('featurePatterns', DEFAULT_FEATURE_PATTERNS);
  const genericNames = [
    'src', 'lib', 'app', 'components', 'pages', 'utils', 'hooks',
    'types', 'internal', 'cmd', 'pkg', 'models', 'views',
    'routers', 'controllers', 'services'
  ];

  // Try configured feature patterns
  for (const pattern of featurePatterns) {
    const regex = new RegExp(`${pattern}/([^/]+)`);
    const match = filePath.match(regex);
    if (match && match[1] && !genericNames.includes(match[1])) {
      return match[1];
    }
  }

  // Fallback: extract from parent directory
  const parts = filePath.split(/[/\\]/).filter(Boolean);
  for (let i = parts.length - 2; i >= 0; i--) {
    if (!genericNames.includes(parts[i])) {
      return parts[i];
    }
  }

  return '';
}

// ============================================================
// 5. PDCA Document Detection
// ============================================================

/**
 * Find design document for feature
 * FR-06: Uses fs.accessSync for read permission verification
 * @param {string} feature - Feature name
 * @returns {string} Path to design doc or empty string
 */
function findDesignDoc(feature) {
  if (!feature) return '';

  const paths = [
    path.join(PROJECT_DIR, 'docs', '02-design', 'features', `${feature}.design.md`),
    path.join(PROJECT_DIR, 'docs', '02-design', `${feature}.design.md`),
    path.join(PROJECT_DIR, 'docs', 'design', `${feature}.md`)
  ];

  for (const p of paths) {
    try {
      // FR-06: Verify read permission, not just existence
      fs.accessSync(p, fs.constants.R_OK);
      return p;
    } catch (e) {
      // File doesn't exist or no read permission - try next path
      continue;
    }
  }
  return '';
}

/**
 * Find plan document for feature
 * FR-06: Uses fs.accessSync for read permission verification
 * @param {string} feature - Feature name
 * @returns {string} Path to plan doc or empty string
 */
function findPlanDoc(feature) {
  if (!feature) return '';

  const paths = [
    path.join(PROJECT_DIR, 'docs', '01-plan', 'features', `${feature}.plan.md`),
    path.join(PROJECT_DIR, 'docs', '01-plan', `${feature}.plan.md`),
    path.join(PROJECT_DIR, 'docs', 'plan', `${feature}.md`)
  ];

  for (const p of paths) {
    try {
      // FR-06: Verify read permission, not just existence
      fs.accessSync(p, fs.constants.R_OK);
      return p;
    } catch (e) {
      // File doesn't exist or no read permission - try next path
      continue;
    }
  }
  return '';
}

// ============================================================
// 6. Task Classification
// ============================================================

/**
 * Classify task by content length (legacy, character-based)
 * @param {string} content - Content to classify
 * @returns {string} Classification
 */
function classifyTask(content) {
  const length = (content || '').length;

  const quickFix = getConfig('taskClassification.thresholds.quickFix', 50);
  const minorChange = getConfig('taskClassification.thresholds.minorChange', 200);
  const feature = getConfig('taskClassification.thresholds.feature', 1000);

  if (length < quickFix) return 'quick_fix';
  if (length < minorChange) return 'minor_change';
  if (length < feature) return 'feature';
  return 'major_feature';
}

/**
 * Classify task by line count (v1.3.0, more accurate)
 * @param {string} content - Content to classify
 * @returns {string} Classification
 */
function classifyTaskByLines(content) {
  const lines = (content || '').split('\n');
  const lineCount = lines.length;

  const quickFix = getConfig('taskClassification.lines.quickFix', 10);
  const minorChange = getConfig('taskClassification.lines.minorChange', 50);
  const feature = getConfig('taskClassification.lines.feature', 200);

  if (lineCount < quickFix) return 'quick_fix';
  if (lineCount < minorChange) return 'minor_change';
  if (lineCount < feature) return 'feature';
  return 'major_feature';
}

/**
 * Get PDCA level from classification
 * @param {string} classification - Task classification
 * @returns {string} PDCA level
 */
function getPdcaLevel(classification) {
  const levels = {
    'quick_fix': 'none',
    'minor_change': 'light',
    'feature': 'recommended',
    'major_feature': 'required'
  };
  return levels[classification] || 'none';
}

/**
 * Get PDCA guidance message
 * @param {string} classification - Task classification
 * @returns {string} Guidance message
 */
function getPdcaGuidance(classification) {
  const guidance = {
    'quick_fix': '',
    'minor_change': 'Minor change. PDCA optional.',
    'feature': 'Feature-level change. Design doc recommended. Run /pdca-design.',
    'major_feature': 'Major feature. Design doc strongly recommended. Run /pdca-plan first.'
  };
  return guidance[classification] || '';
}

/**
 * Get contextual PDCA guidance by level
 * @param {string} level - PDCA level
 * @param {string} feature - Feature name
 * @param {number} lineCount - Line count
 * @returns {string} Guidance message
 */
function getPdcaGuidanceByLevel(level, feature = '', lineCount = 0) {
  const lineInfo = lineCount > 0 ? ` (${lineCount} lines)` : '';
  const featureInfo = feature ? ` for '${feature}'` : '';

  switch (level) {
    case 'none':
      return '';
    case 'light':
      return `Minor change${lineInfo}. PDCA optional.`;
    case 'recommended':
      return `Feature${lineInfo}. Design doc recommended${featureInfo}.`;
    case 'required':
      return `Major feature${lineInfo}. Design doc strongly recommended${featureInfo}.`;
    default:
      return '';
  }
}

// ============================================================
// 7. JSON Output Helpers (Dual Platform Support)
// ============================================================

/**
 * Maximum context message length (FR-04)
 * Prevents UI truncation issues
 */
const MAX_CONTEXT_LENGTH = 500;

/**
 * Truncate context message to prevent UI issues (FR-04)
 * Attempts to cut at last complete sentence
 * @param {string} context - Original context message
 * @param {number} maxLength - Maximum length (default: 500)
 * @returns {string} - Truncated context
 */
function truncateContext(context, maxLength = MAX_CONTEXT_LENGTH) {
  if (!context || typeof context !== 'string') return '';
  if (context.length <= maxLength) return context;

  // Try to cut at last complete sentence
  const truncated = context.substring(0, maxLength - 3);
  const lastPeriod = truncated.lastIndexOf('.');
  const lastPipe = truncated.lastIndexOf(' | ');

  const cutPoint = Math.max(lastPeriod, lastPipe);
  if (cutPoint > maxLength * 0.7) {
    return context.substring(0, cutPoint + 1) + '...';
  }

  return truncated + '...';
}

/**
 * Output allow decision with context
 * v1.4.2: Claude Code API Ïä§ÌÇ§Îßà ÏôÑÏ†Ñ Ï§ÄÏàò (ISSUE-003, ISSUE-006 ÏàòÏ†ï)
 * @param {string} context - Additional context
 * @param {string} hookEvent - Hook event type: 'PreToolUse' | 'PostToolUse' | 'SessionStart' | 'UserPromptSubmit' | 'Stop' | 'PreCompact'
 */
function outputAllow(context = '', hookEvent = 'PostToolUse') {
  // Apply context length limit (FR-04)
  const safeContext = truncateContext(context, MAX_CONTEXT_LENGTH);

  if (isGeminiCli()) {
    // Gemini CLI: Print plain text context if available
    // FR-1.1: Apply XML escaping for v0.27+ hook context XML wrapping compatibility
    if (safeContext) {
      // Use cyan color for informational context
      const escapedContext = xmlSafeOutput(safeContext);
      console.log(`\x1b[36müí° bkit Context:\x1b[0m ${escapedContext}`);
    }
    process.exit(0);
  } else {
    // Claude Code: Print JSON based on hook event type
    if (!safeContext) {
      console.log('{}');
      return;
    }

    // v1.4.2: Hook eventÎ≥Ñ Claude Code API Ïä§ÌÇ§Îßà Ï§ÄÏàò
    // - PreToolUse: hookEventName + additionalContext (decision Ï†úÍ±∞, GitHub Issue #16598 ÌöåÌîº)
    // - UserPromptSubmit: hookEventName + additionalContext (ISSUE-003: decision ÌïÑÎìú ÎØ∏ÏßÄÏõê)
    // - PostToolUse/SessionStart/PreCompact: hookEventName + additionalContext
    // - Stop: systemMessage (additionalContext ÎØ∏ÏßÄÏõê)
    if (hookEvent === 'Stop') {
      // Stop hooks don't support additionalContext, use systemMessage
      console.log(JSON.stringify({
        systemMessage: safeContext
      }));
    } else if (hookEvent === 'UserPromptSubmit') {
      // ISSUE-003 ÏàòÏ†ï: UserPromptSubmitÏùÄ decision ÌïÑÎìú ÎØ∏ÏßÄÏõê
      // ISSUE-006 ÏàòÏ†ï: hookEventName ÌïÑÎìú Ï∂îÍ∞Ä
      console.log(JSON.stringify({
        hookSpecificOutput: {
          hookEventName: 'UserPromptSubmit',
          additionalContext: safeContext
        }
      }));
    } else if (hookEvent === 'PreToolUse') {
      // FR-01: permissionDecision: "allow" Ï†úÍ±∞ (GitHub Issue #16598 ÌöåÌîº)
      // Exit Code 0ÎßåÏúºÎ°ú ÌóàÏö© ÏùòÎØ∏ Ï†ÑÎã¨, additionalContextÎ°ú Ïª®ÌÖçÏä§Ìä∏ Ï†úÍ≥µ
      // ISSUE-006 ÏàòÏ†ï: hookEventName ÌïÑÎìú Ï∂îÍ∞Ä
      console.log(JSON.stringify({
        hookSpecificOutput: {
          hookEventName: 'PreToolUse',
          additionalContext: safeContext
        }
      }));
    } else {
      // PostToolUse, SessionStart, PreCompact
      // ISSUE-006 ÏàòÏ†ï: hookEventName ÌïÑÎìú Ï∂îÍ∞Ä
      console.log(JSON.stringify({
        hookSpecificOutput: {
          hookEventName: hookEvent,
          additionalContext: safeContext
        }
      }));
    }
  }
}

/**
 * Output block decision with reason and exit
 * FR-02: Use stderr + Exit Code 2 for most stable blocking (Best Practice)
 * @param {string} reason - Block reason
 */
function outputBlock(reason) {
  if (isGeminiCli()) {
    // Gemini CLI: Print error to stderr and exit non-zero
    // FR-1.1: Apply XML escaping for v0.27+ hook context XML wrapping compatibility
    const escapedReason = xmlSafeOutput(reason);
    console.error(`\x1b[31müö´ bkit Blocked:\x1b[0m ${escapedReason}`);
    process.exit(1);
  } else {
    // FR-02: Claude Code Best Practice - stderr + Exit Code 2
    // JSON stdout is ignored when Exit Code 2, use stderr instead
    console.error(reason);
    process.exit(2);
  }
}

/**
 * Output empty JSON or nothing
 */
function outputEmpty() {
  if (isGeminiCli()) {
    // Gemini CLI: Do nothing
    process.exit(0);
  } else {
    // Claude Code: Print empty JSON
    console.log('{}');
  }
}

/**
 * Escape XML special characters for safe output in Gemini CLI v0.27+ XML-wrapped context
 * FR-1.1: Hook Context XML Wrapping Compatibility
 * @param {string} content - Content to escape
 * @returns {string} XML-safe escaped content
 */
function xmlSafeOutput(content) {
  if (!content || typeof content !== 'string') {
    return content;
  }
  return content
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// ============================================================
// 8. Level Detection
// ============================================================

/**
 * Detect project level from CLAUDE.md, GEMINI.md, or structure
 * @returns {string} "Starter" | "Dynamic" | "Enterprise"
 */
function detectLevel() {
  // 1. Check CLAUDE.md or GEMINI.md for explicit declaration (v1.4.0)
  const contextFiles = ['CLAUDE.md', 'GEMINI.md'];
  for (const file of contextFiles) {
    const filePath = path.join(PROJECT_DIR, file);
    if (fs.existsSync(filePath)) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        const match = content.match(/^level:\s*(\w+)/im);
        if (match) {
          const level = match[1].toLowerCase();
          if (['starter', 'dynamic', 'enterprise'].includes(level)) {
            return level.charAt(0).toUpperCase() + level.slice(1);
          }
        }
      } catch (e) { /* ignore */ }
    }
  }

  // 2. Check for Enterprise indicators
  const enterpriseDirs = ['kubernetes', 'terraform', 'k8s', 'infra'];
  for (const dir of enterpriseDirs) {
    const dirPath = path.join(PROJECT_DIR, dir);
    if (fs.existsSync(dirPath)) {
      try {
        if (fs.statSync(dirPath).isDirectory()) return 'Enterprise';
      } catch (e) { /* ignore */ }
    }
  }

  // 3. Check for Dynamic indicators
  const mcpJson = path.join(PROJECT_DIR, '.mcp.json');
  if (fs.existsSync(mcpJson)) {
    try {
      const content = fs.readFileSync(mcpJson, 'utf8');
      if (content.includes('bkend')) return 'Dynamic';
    } catch (e) { /* ignore */ }
  }

  const dynamicIndicators = ['lib/bkend', 'supabase', 'docker-compose.yml', 'api', 'backend'];
  for (const indicator of dynamicIndicators) {
    if (fs.existsSync(path.join(PROJECT_DIR, indicator))) {
      return 'Dynamic';
    }
  }

  // 4. Default to Starter
  return 'Starter';
}

// ============================================================
// 9. Input Helpers (New for v1.3.1)
// ============================================================

/**
 * Read JSON from stdin synchronously
 * FR-03: Added error logging for debugging
 * @returns {Object} Parsed JSON or empty object
 */
function readStdinSync() {
  let data = '';
  try {
    // Read from file descriptor 0 (stdin)
    data = fs.readFileSync(0, 'utf8');
    if (!data || data.trim() === '') {
      debugLog('Input', 'stdin is empty');
      return {};
    }
    return JSON.parse(data);
  } catch (e) {
    // FR-03: Log parsing errors for debugging
    debugLog('Input', 'Failed to parse stdin JSON', {
      error: e.message,
      errorName: e.name,
      dataPreview: (data || '').substring(0, 100)
    });
    return {};
  }
}

/**
 * Read JSON from stdin asynchronously
 * @returns {Promise<Object>} Parsed JSON
 */
async function readStdin() {
  return new Promise((resolve) => {
    let data = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('readable', () => {
      let chunk;
      while ((chunk = process.stdin.read()) !== null) {
        data += chunk;
      }
    });
    process.stdin.on('end', () => {
      try {
        resolve(data ? JSON.parse(data) : {});
      } catch (e) {
        resolve({});
      }
    });
    process.stdin.on('error', () => resolve({}));
  });
}

/**
 * Parse hook input and extract common fields
 * @param {Object} input - Raw hook input
 * @returns {Object} Parsed fields
 */
function parseHookInput(input) {
  return {
    toolName: input.tool_name || '',
    filePath: input.tool_input?.file_path || input.tool_input?.path || '',
    content: input.tool_input?.content || input.tool_input?.new_string || '',
    command: input.tool_input?.command || '',
    oldString: input.tool_input?.old_string || ''
  };
}

// ============================================================
// 10. Task System Integration (v1.3.1 - FR-01~05)
// ============================================================

/**
 * PDCA Phase definitions for Task System integration
 */
const PDCA_PHASES = {
  plan: { order: 1, name: 'Plan', emoji: 'üìã' },
  design: { order: 2, name: 'Design', emoji: 'üìê' },
  do: { order: 3, name: 'Do', emoji: 'üî®' },
  check: { order: 4, name: 'Check', emoji: 'üîç' },
  act: { order: 5, name: 'Act', emoji: 'üîÑ' }
};

/**
 * Generate PDCA Task metadata for Task System integration
 * @param {string} phase - PDCA phase (plan|design|do|check|act)
 * @param {string} feature - Feature name
 * @param {Object} options - Additional options
 * @returns {Object} Task metadata
 */
function getPdcaTaskMetadata(phase, feature, options = {}) {
  const phaseInfo = PDCA_PHASES[phase.toLowerCase()] || PDCA_PHASES.do;

  return {
    pdcaPhase: phase.toLowerCase(),
    pdcaOrder: phaseInfo.order,
    feature: feature || '',
    level: options.level || detectLevel(),
    createdAt: new Date().toISOString(),
    ...options
  };
}

/**
 * Generate Task subject for PDCA phase
 * @param {string} phase - PDCA phase
 * @param {string} feature - Feature name
 * @returns {string} Task subject
 */
function generatePdcaTaskSubject(phase, feature) {
  const phaseInfo = PDCA_PHASES[phase.toLowerCase()] || PDCA_PHASES.do;
  const featureName = feature || 'current task';
  return `[${phaseInfo.name}] ${featureName}`;
}

/**
 * Generate Task description for PDCA phase
 * @param {string} phase - PDCA phase
 * @param {string} feature - Feature name
 * @param {string} docPath - Document path if applicable
 * @returns {string} Task description
 */
function generatePdcaTaskDescription(phase, feature, docPath = '') {
  const phaseDescriptions = {
    plan: `Feature planning for '${feature}'.\nDocument: ${docPath || `docs/01-plan/features/${feature}.plan.md`}`,
    design: `Feature design for '${feature}'.\nDocument: ${docPath || `docs/02-design/features/${feature}.design.md`}`,
    do: `Implementation of '${feature}'.`,
    check: `Gap analysis for '${feature}'.\nDocument: ${docPath || `docs/03-analysis/${feature}.analysis.md`}`,
    act: `Iteration/Report for '${feature}'.\nDocument: ${docPath || `docs/04-report/${feature}.report.md`}`
  };

  return phaseDescriptions[phase.toLowerCase()] || `PDCA ${phase} for ${feature}`;
}

/**
 * Generate Task creation guidance for hooks
 * @param {string} phase - PDCA phase
 * @param {string} feature - Feature name
 * @param {string} blockedByPhase - Previous phase that blocks this (optional)
 * @returns {string} Guidance message for additionalContext
 */
function generateTaskGuidance(phase, feature, blockedByPhase = '') {
  const phaseInfo = PDCA_PHASES[phase.toLowerCase()];
  if (!phaseInfo) return '';

  const subject = generatePdcaTaskSubject(phase, feature);
  const metadata = getPdcaTaskMetadata(phase, feature);

  let guidance = `üí° Task System: Create task "${subject}" with metadata ${JSON.stringify(metadata)}`;

  if (blockedByPhase) {
    const prevPhaseInfo = PDCA_PHASES[blockedByPhase.toLowerCase()];
    if (prevPhaseInfo) {
      guidance += ` | blockedBy: [${prevPhaseInfo.name}] ${feature}`;
    }
  }

  return guidance;
}

/**
 * Get the previous PDCA phase for dependency
 * @param {string} currentPhase - Current PDCA phase
 * @returns {string|null} Previous phase or null
 */
function getPreviousPdcaPhase(currentPhase) {
  const order = {
    plan: null,
    design: 'plan',
    do: 'design',
    check: 'do',
    act: 'check'
  };
  return order[currentPhase.toLowerCase()] || null;
}

/**
 * Find existing PDCA status file
 * @returns {Object|null} PDCA status or null
 */
function findPdcaStatus() {
  const statusPath = path.join(PROJECT_DIR, 'docs/.pdca-status.json');
  try {
    if (fs.existsSync(statusPath)) {
      return JSON.parse(fs.readFileSync(statusPath, 'utf8'));
    }
  } catch (e) { /* ignore */ }
  return null;
}

/**
 * Get current PDCA phase from status
 * @param {string} feature - Feature name
 * @returns {string|null} Current phase or null
 */
function getCurrentPdcaPhase(feature) {
  const status = findPdcaStatus();
  if (!status || !status.features) return null;

  const featureStatus = status.features[feature];
  if (!featureStatus) return null;

  return featureStatus.currentPhase || null;
}

// ============================================================
// v1.4.4 FR-11: LevelÎ≥Ñ Phase Skip ÏûêÎèôÌôî
// ============================================================

/**
 * LevelÎ≥ÑÎ°ú Í±¥ÎÑàÎõ∏ Ïàò ÏûàÎäî Phase Îßµ
 * - Starter: Phase 4,5,7,8 Í±¥ÎÑàÎõ∞Í∏∞ Í∞ÄÎä• (Ï†ïÏ†Å Ïõπ)
 * - Dynamic: Phase 8Îßå Í±¥ÎÑàÎõ∞Í∏∞ Í∞ÄÎä• (fullstack but simpler review)
 * - Enterprise: Î™®Îì† Phase ÌïÑÏàò
 */
const LEVEL_PHASE_MAP = {
  Starter: {
    required: [1, 2, 3, 6, 9],      // Schema, Convention, Mockup, UI, Deploy
    optional: [4, 5, 7, 8],          // API, Design System, SEO/Security, Review
    skipReasons: {
      4: 'Ï†ïÏ†Å ÏõπÏÇ¨Ïù¥Ìä∏Îäî API ÏÑ§Í≥ÑÍ∞Ä ÌïÑÏöî ÏóÜÏùå',
      5: 'Îã®Ïàú ÌîÑÎ°úÏ†ùÌä∏Îäî ÎîîÏûêÏù∏ ÏãúÏä§ÌÖú ÏÉùÎûµ Í∞ÄÎä•',
      7: 'Í∏∞Î≥∏ SEO/Î≥¥ÏïàÎßå Ï†ÅÏö©',
      8: 'Í∞ÑÎã®Ìïú ÌîÑÎ°úÏ†ùÌä∏Îäî Î¶¨Î∑∞ ÏÉùÎûµ Í∞ÄÎä•'
    }
  },
  Dynamic: {
    required: [1, 2, 3, 4, 5, 6, 7, 9],  // Phase 8 optional
    optional: [8],
    skipReasons: {
      8: 'Ï§ëÏÜåÍ∑úÎ™® fullstack ÌîÑÎ°úÏ†ùÌä∏Îäî Î¶¨Î∑∞ Îã®Í≥Ñ ÏÑ†ÌÉùÏ†Å'
    }
  },
  Enterprise: {
    required: [1, 2, 3, 4, 5, 6, 7, 8, 9],  // All required
    optional: [],
    skipReasons: {}
  }
};

/**
 * Check if a phase can be skipped for a given level
 * @param {string} level - Project level (Starter/Dynamic/Enterprise)
 * @param {number} phase - Phase number (1-9)
 * @returns {{ canSkip: boolean, reason: string|null }}
 */
function canSkipPhase(level, phase) {
  const levelConfig = LEVEL_PHASE_MAP[level] || LEVEL_PHASE_MAP.Dynamic;
  const isOptional = levelConfig.optional.includes(phase);

  return {
    canSkip: isOptional,
    reason: isOptional ? levelConfig.skipReasons[phase] : null
  };
}

/**
 * Get required phases for a level
 * @param {string} level - Project level
 * @returns {number[]} Array of required phase numbers
 */
function getRequiredPhases(level) {
  const levelConfig = LEVEL_PHASE_MAP[level] || LEVEL_PHASE_MAP.Dynamic;
  return levelConfig.required;
}

/**
 * Get next phase for a given level (v1.4.4 - FR-11)
 * Skips phases that are optional for the level
 * @param {number} currentPhase - Current phase number (1-9)
 * @param {string} level - Project level (Starter/Dynamic/Enterprise)
 * @returns {number|null} Next phase number or null if completed
 */
function getNextPhaseForLevel(currentPhase, level) {
  const normalizedLevel = (level || 'Dynamic').charAt(0).toUpperCase() + (level || 'Dynamic').slice(1).toLowerCase();
  const levelConfig = LEVEL_PHASE_MAP[normalizedLevel] || LEVEL_PHASE_MAP.Dynamic;
  const requiredPhases = levelConfig.required;

  const currentIndex = requiredPhases.indexOf(currentPhase);

  if (currentIndex === -1) {
    // Current phase not in required list, find next higher required phase
    const nextPhases = requiredPhases.filter(p => p > currentPhase);
    return nextPhases.length > 0 ? nextPhases[0] : null;
  }

  if (currentIndex < requiredPhases.length - 1) {
    return requiredPhases[currentIndex + 1];
  }

  return null; // Completed all phases
}

/**
 * Check if a phase is applicable (required) for a given level (v1.4.4 - FR-11)
 * @param {number} phase - Phase number (1-9)
 * @param {string} level - Project level (Starter/Dynamic/Enterprise)
 * @returns {boolean} True if phase is required for this level
 */
function isPhaseApplicable(phase, level) {
  const normalizedLevel = (level || 'Dynamic').charAt(0).toUpperCase() + (level || 'Dynamic').slice(1).toLowerCase();
  const levelConfig = LEVEL_PHASE_MAP[normalizedLevel] || LEVEL_PHASE_MAP.Dynamic;
  return levelConfig.required.includes(phase);
}

/**
 * Get level-specific phase guide message (v1.4.4 - FR-11)
 * @param {string} level - Project level (Starter/Dynamic/Enterprise)
 * @returns {string} Formatted guide message
 */
function getLevelPhaseGuide(level) {
  const normalizedLevel = (level || 'Dynamic').charAt(0).toUpperCase() + (level || 'Dynamic').slice(1).toLowerCase();
  const levelConfig = LEVEL_PHASE_MAP[normalizedLevel] || LEVEL_PHASE_MAP.Dynamic;

  const phaseNames = {
    1: 'Schema',
    2: 'Convention',
    3: 'Mockup',
    4: 'API',
    5: 'Design System',
    6: 'UI Implementation',
    7: 'SEO/Security',
    8: 'Review',
    9: 'Deployment'
  };

  const requiredStr = levelConfig.required
    .map(p => `Phase ${p}: ${phaseNames[p]}`)
    .join(' ‚Üí ');

  const optionalStr = levelConfig.optional.length > 0
    ? `\nÏÑ†ÌÉùÏ†Å: ${levelConfig.optional.map(p => `Phase ${p}: ${phaseNames[p]}`).join(', ')}`
    : '';

  return `${normalizedLevel} Level Pipeline:\n${requiredStr}${optionalStr}`;
}

/**
 * Update PDCA Task status in .pdca-status.json (v1.4.4 - FR-07)
 * @param {string} phase - PDCA phase ('plan', 'design', 'do', 'check', 'act', 'report')
 * @param {string} feature - Feature name
 * @param {Object} updates - Update fields { matchRate, status, iteration, ... }
 * @returns {Object|null} Updated task info or null if not found
 */
function updatePdcaTaskStatus(phase, feature, updates = {}) {
  const status = getPdcaStatusFull();

  // Ensure nested structure exists
  if (!status.features) status.features = {};
  if (!status.features[feature]) status.features[feature] = {};
  if (!status.features[feature].tasks) status.features[feature].tasks = {};

  // Get or create task entry for this phase
  if (!status.features[feature].tasks[phase]) {
    status.features[feature].tasks[phase] = {
      createdAt: new Date().toISOString(),
      status: 'pending'
    };
  }

  // Apply updates
  Object.assign(status.features[feature].tasks[phase], {
    ...updates,
    updatedAt: new Date().toISOString()
  });

  // Save updated status
  savePdcaStatus(status);

  debugLog('TaskSystem', 'Task status updated', {
    phase,
    feature,
    updates: Object.keys(updates)
  });

  return status.features[feature].tasks[phase];
}

// ============================================================
// 10.1 Task ID Persistence (v1.4.7 - FR-02, FR-03)
// ============================================================

/**
 * Save Task ID to .pdca-status.json for session persistence (v1.4.7 FR-02)
 * @param {string} feature - Feature name
 * @param {string} phase - PDCA phase ('plan', 'design', 'do', 'check', 'act', 'report')
 * @param {string} taskId - Task ID to save
 * @param {Object} options - Additional options
 * @param {number} options.iteration - Iteration number for Act phase
 * @returns {boolean} True if saved successfully
 */
function savePdcaTaskId(feature, phase, taskId, options = {}) {
  const { iteration } = options;

  try {
    const pdcaStatus = getPdcaStatusFull();

    // Initialize feature structure if not exists
    if (!pdcaStatus.features) {
      pdcaStatus.features = {};
    }
    if (!pdcaStatus.features[feature]) {
      pdcaStatus.features[feature] = {
        phase: phase,
        phaseNumber: PDCA_PHASES[phase]?.order || 0,
        tasks: {
          plan: null,
          design: null,
          do: null,
          check: null,
          act: [],
          report: null
        },
        taskChainCreated: false,
        currentTaskId: null,
        timestamps: {
          started: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        }
      };
    }

    // Initialize tasks structure (migration for existing features)
    if (!pdcaStatus.features[feature].tasks) {
      pdcaStatus.features[feature].tasks = {
        plan: null, design: null, do: null,
        check: null, act: [], report: null
      };
    }

    // Save Task ID
    const tasks = pdcaStatus.features[feature].tasks;

    if (phase === 'act') {
      // Act is an array (supports iterations)
      if (!Array.isArray(tasks.act)) {
        tasks.act = [];
      }
      // Prevent duplicates
      if (!tasks.act.includes(taskId)) {
        tasks.act.push(taskId);
      }
    } else {
      // Other phases are single values
      tasks[phase] = taskId;
    }

    // Update current active Task
    pdcaStatus.features[feature].currentTaskId = taskId;
    pdcaStatus.features[feature].timestamps.lastUpdated = new Date().toISOString();

    // Save
    savePdcaStatus(pdcaStatus);

    debugLog('TaskPersistence', 'Task ID saved successfully', {
      feature, phase, taskId, iteration
    });

    return true;
  } catch (error) {
    debugLog('TaskPersistence', 'Failed to save Task ID', {
      feature, phase, taskId, error: error.message
    });
    return false;
  }
}

/**
 * Get saved Task ID from .pdca-status.json (v1.4.7 FR-03)
 * @param {string} feature - Feature name
 * @param {string} phase - PDCA phase
 * @param {Object} options - Query options
 * @param {number} options.iteration - Specific Act iteration to retrieve
 * @param {boolean} options.latest - Get latest Act Task (default: true)
 * @returns {string|null} Task ID or null if not found
 */
function getPdcaTaskId(feature, phase, options = {}) {
  const { iteration, latest = true } = options;

  try {
    const pdcaStatus = getPdcaStatusFull();
    const tasks = pdcaStatus?.features?.[feature]?.tasks;

    if (!tasks) return null;

    if (phase === 'act') {
      const actTasks = tasks.act || [];
      if (actTasks.length === 0) return null;

      if (typeof iteration === 'number' && iteration > 0) {
        // Get specific iteration
        return actTasks[iteration - 1] || null;
      }
      // Get latest
      return latest ? actTasks[actTasks.length - 1] : actTasks[0];
    }

    return tasks[phase] || null;
  } catch (error) {
    debugLog('TaskPersistence', 'Failed to get Task ID', {
      feature, phase, error: error.message
    });
    return null;
  }
}

/**
 * Create full PDCA Task chain upfront (v1.4.7 FR-01)
 * Generates Plan ‚Üí Design ‚Üí Do ‚Üí Check ‚Üí Report Task chain
 * Act Tasks are created dynamically based on Check results
 *
 * @param {string} feature - Feature name
 * @param {Object} options - Options
 * @param {boolean} options.skipIfExists - Skip if chain already exists (default: true)
 * @param {boolean} options.includeReport - Include Report Task (default: true)
 * @returns {Object|null} TaskChain object or null if already exists
 */
function createPdcaTaskChain(feature, options = {}) {
  const { skipIfExists = true, includeReport = true } = options;

  try {
    const pdcaStatus = getPdcaStatusFull();

    // Check if chain already exists
    if (skipIfExists && pdcaStatus?.features?.[feature]?.taskChainCreated) {
      debugLog('TaskChain', 'Chain already exists, skipping', { feature });
      return null;
    }

    // Create Task chain
    const timestamp = Date.now();
    const phases = ['plan', 'design', 'do', 'check'];
    if (includeReport) phases.push('report');

    const entries = [];
    phases.forEach((phase, index) => {
      const taskId = `${phase}-${feature}-${timestamp + index}`;
      const entry = {
        id: taskId,
        phase,
        subject: generatePdcaTaskSubject(phase, feature),
        description: generatePdcaTaskDescription(phase, feature),
        status: index === 0 ? 'in_progress' : 'pending',
        blockedBy: index > 0 ? [entries[index - 1].id] : [],
        metadata: getPdcaTaskMetadata(phase, feature, {})
      };
      entries.push(entry);
    });

    // Save to .pdca-status.json
    if (!pdcaStatus.features) pdcaStatus.features = {};
    if (!pdcaStatus.features[feature]) {
      pdcaStatus.features[feature] = {
        phase: 'plan',
        phaseNumber: 1,
        timestamps: {
          started: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        }
      };
    }

    // Save Task IDs
    pdcaStatus.features[feature].tasks = {
      plan: entries[0]?.id || null,
      design: entries[1]?.id || null,
      do: entries[2]?.id || null,
      check: entries[3]?.id || null,
      act: [],
      report: includeReport ? entries[4]?.id || null : null
    };
    pdcaStatus.features[feature].taskChainCreated = true;
    pdcaStatus.features[feature].currentTaskId = entries[0]?.id || null;

    savePdcaStatus(pdcaStatus);

    debugLog('TaskChain', 'Task chain created', {
      feature,
      taskCount: entries.length,
      phases
    });

    return {
      feature,
      entries,
      createdAt: new Date().toISOString()
    };
  } catch (error) {
    debugLog('TaskChain', 'Failed to create Task chain', {
      feature, error: error.message
    });
    return null;
  }
}

/**
 * Get Task chain visualization for status display (v1.4.7 FR-12)
 * @param {string} feature - Feature name
 * @returns {string} Formatted Task chain status
 */
function getTaskChainStatus(feature) {
  const pdcaStatus = getPdcaStatusFull();
  const featureData = pdcaStatus?.features?.[feature];

  if (!featureData?.tasks) {
    return `No Task chain found for "${feature}"`;
  }

  const tasks = featureData.tasks;
  const currentPhase = featureData.phase || 'plan';
  const matchRate = featureData.matchRate;

  const phaseEmojis = {
    plan: 'üìã', design: 'üìê', do: 'üî®',
    check: 'üîç', act: 'üîÑ', report: 'üìä'
  };

  const lines = [
    `üìã PDCA Task Chain: "${feature}"`,
    '‚îÄ'.repeat(50)
  ];

  // Phase status indicators
  const phases = ['plan', 'design', 'do', 'check', 'report'];
  const indicators = phases.map(phase => {
    const phaseOrder = PDCA_PHASES[phase]?.order || 0;
    const currentOrder = PDCA_PHASES[currentPhase]?.order || 0;

    if (phaseOrder < currentOrder) return '‚úÖ';
    if (phaseOrder === currentOrder) return 'üîÑ';
    return '‚è≥';
  });

  lines.push(`[Plan] ${indicators[0]} ‚Üí [Design] ${indicators[1]} ‚Üí [Do] ${indicators[2]} ‚Üí [Check] ${indicators[3]} ‚Üí [Report] ${indicators[4]}`);

  if (matchRate !== null && matchRate !== undefined) {
    lines.push(`Match Rate: ${matchRate}%`);
  }

  if (Array.isArray(tasks.act) && tasks.act.length > 0) {
    lines.push(`Act Iterations: ${tasks.act.length}`);
  }

  lines.push('‚îÄ'.repeat(50));

  return lines.join('\n');
}

/**
 * Trigger next PDCA action for Check‚ÜîAct iteration (v1.4.7 FR-04, FR-05, FR-06)
 *
 * @param {string} feature - Feature name
 * @param {string} currentPhase - Current completed phase ('check' or 'act')
 * @param {Object} context - Context object
 * @param {number} context.matchRate - Match rate from Check phase
 * @param {number} context.iterationCount - Current iteration count
 * @param {number} context.maxIterations - Max iterations (default: 5)
 * @param {number} context.threshold - Match rate threshold (default: 90)
 * @returns {Object|null} Trigger result { nextAction, taskId, autoTrigger, message }
 */
function triggerNextPdcaAction(feature, currentPhase, context = {}) {
  const {
    matchRate = 0,
    iterationCount = 0,
    maxIterations = 5,
    threshold = 90
  } = context;

  try {
    // Check phase completed - decide next action
    if (currentPhase === 'check') {
      if (matchRate >= threshold) {
        // FR-06: Ready for Report
        const reportTaskId = getPdcaTaskId(feature, 'report');
        return {
          nextAction: 'report',
          taskId: reportTaskId,
          autoTrigger: {
            skill: '/pdca report',
            feature,
            reason: `Match rate ${matchRate}% >= ${threshold}%. Ready for report.`
          },
          message: `‚úÖ Match rate ${matchRate}% >= ${threshold}%. ÏôÑÎ£å Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Í∞ÄÎä•.`
        };
      } else if (iterationCount < maxIterations) {
        // FR-04: Need Act iteration
        const nextIteration = iterationCount + 1;
        const actTask = autoCreatePdcaTask({
          phase: 'act',
          feature,
          iteration: nextIteration,
          metadata: {
            matchRateBefore: matchRate,
            iterationNumber: nextIteration
          }
        });

        return {
          nextAction: 'act',
          taskId: actTask?.taskId,
          autoTrigger: {
            agent: 'pdca-iterator',
            skill: '/pdca iterate',
            feature,
            reason: `Match rate ${matchRate}% < ${threshold}%. Iteration ${nextIteration}/${maxIterations}.`
          },
          message: `üîÑ Match rate ${matchRate}% < ${threshold}%. ÏûêÎèô Í∞úÏÑ† ${nextIteration}/${maxIterations} ÏãúÏûë.`
        };
      } else {
        // Max iterations reached
        return {
          nextAction: 'manual',
          taskId: null,
          autoTrigger: null,
          message: `‚ö†Ô∏è ÏµúÎåÄ Î∞òÎ≥µ ÌöüÏàò(${maxIterations})Ïóê ÎèÑÎã¨. ÏàòÎèô Í≤ÄÌÜ† ÌïÑÏöî.`
        };
      }
    }

    // Act phase completed - re-run Check (FR-05)
    if (currentPhase === 'act') {
      const checkTaskId = getPdcaTaskId(feature, 'check');
      return {
        nextAction: 'check',
        taskId: checkTaskId,
        autoTrigger: {
          agent: 'gap-detector',
          skill: '/pdca analyze',
          feature,
          reason: 'Iteration complete. Re-running gap analysis.'
        },
        message: 'üîç Í∞úÏÑ† ÏôÑÎ£å. Gap Î∂ÑÏÑù Ïû¨Ïã§Ìñâ.'
      };
    }

    return null;
  } catch (error) {
    debugLog('TriggerNextAction', 'Failed to trigger next action', {
      feature, currentPhase, error: error.message
    });
    return null;
  }
}

// ============================================================
// 10.2 Full-Auto Mode Functions (v1.4.7 - Section 11)
// ============================================================

/**
 * Get current automation level from config (v1.4.7)
 * @returns {'manual' | 'semi-auto' | 'full-auto'} Automation level
 */
function getAutomationLevel() {
  // Check environment variable first
  const envLevel = process.env.BKIT_PDCA_AUTOMATION;
  if (envLevel && ['manual', 'semi-auto', 'full-auto'].includes(envLevel)) {
    return envLevel;
  }

  const config = getBkitConfig();
  return config.pdca?.automationLevel || 'manual';
}

/**
 * Check if full-auto mode is enabled (v1.4.7)
 * @returns {boolean} True if full-auto mode
 */
function isFullAutoMode() {
  return getAutomationLevel() === 'full-auto';
}

/**
 * Check if should auto-advance from given phase (v1.4.7)
 * @param {string} phase - Current PDCA phase
 * @returns {boolean} True if should auto-advance
 */
function shouldAutoAdvance(phase) {
  const level = getAutomationLevel();
  const config = getBkitConfig();

  // manual: Never auto-advance
  if (level === 'manual') return false;

  // semi-auto: Only Check‚ÜîAct auto-advance
  if (level === 'semi-auto') {
    return ['check', 'act'].includes(phase);
  }

  // full-auto: Check reviewCheckpoints
  if (level === 'full-auto') {
    const checkpoints = config.pdca?.fullAuto?.reviewCheckpoints || [];
    return !checkpoints.includes(phase);
  }

  return false;
}

/**
 * Generate autoTrigger for next phase transition (v1.4.7)
 * @param {string} currentPhase - Current completed phase
 * @param {Object} context - { feature, matchRate, iterationCount }
 * @returns {Object|null} AutoTrigger object or null
 */
function generateAutoTrigger(currentPhase, context = {}) {
  if (!shouldAutoAdvance(currentPhase)) return null;

  const { feature, matchRate = 0, iterationCount = 0 } = context;
  const config = getBkitConfig();
  const threshold = config.pdca?.matchRateThreshold || 90;
  const maxIterations = config.pdca?.maxIterations || 5;

  // Phase transition map
  const transitionMap = {
    plan: { next: 'design', skill: '/pdca design' },
    design: { next: 'do', skill: '/pdca do' },
    do: { next: 'check', skill: '/pdca analyze' },
    check: matchRate >= threshold
      ? { next: 'report', skill: '/pdca report' }
      : iterationCount < maxIterations
        ? { next: 'act', skill: '/pdca iterate' }
        : null,
    act: { next: 'check', skill: '/pdca analyze' }
  };

  const transition = transitionMap[currentPhase];
  if (!transition) return null;

  return {
    phase: transition.next,
    skill: `${transition.skill} ${feature || ''}`.trim(),
    feature,
    reason: `Auto-advance from ${currentPhase} (${getAutomationLevel()} mode)`,
    delay: 0
  };
}

/**
 * Auto-create PDCA Task with dependency chain (FR-06, v1.4.4 enhanced)
 * Task Classification determines whether Task is created
 * Supports both old signature (feature, phase, options) and new object signature
 *
 * @param {string|Object} featureOrConfig - Feature name OR config object
 * @param {string} [phase] - PDCA phase (if using old signature)
 * @param {Object} [options] - Additional options (if using old signature)
 * @returns {Object|null} Task creation guidance or null if skipped
 */
function autoCreatePdcaTask(featureOrConfig, phase, options = {}) {
  // v1.4.4: Support object-based signature
  let feature, actualPhase, actualOptions;

  if (typeof featureOrConfig === 'object' && featureOrConfig !== null) {
    // New object signature: autoCreatePdcaTask({ phase, feature, metadata, iteration })
    feature = featureOrConfig.feature;
    actualPhase = featureOrConfig.phase;
    actualOptions = {
      ...featureOrConfig,
      metadata: featureOrConfig.metadata || {},
      iteration: featureOrConfig.iteration
    };
  } else {
    // Old positional signature: autoCreatePdcaTask(feature, phase, options)
    feature = featureOrConfig;
    actualPhase = phase;
    actualOptions = options;
  }

  // Task Classification based skip decision
  const classification = actualOptions.classification || 'feature';
  const skipLevels = ['quick_fix', 'minor_change'];

  // Quick Fix, Minor Change skip Task creation
  if (skipLevels.includes(classification) || actualOptions.skipTask) {
    debugLog('TaskSystem', 'Task creation skipped (small change)', {
      classification,
      feature,
      phase: actualPhase
    });
    return null;  // No Task creation
  }

  // v1.4.4: Handle iteration suffix for Act phase
  let subjectPhase = actualPhase;
  if (actualPhase === 'act' && actualOptions.iteration) {
    subjectPhase = `act-${actualOptions.iteration}`;
  }

  const subject = generatePdcaTaskSubject(subjectPhase, feature);
  const description = generatePdcaTaskDescription(actualPhase, feature, actualOptions.docPath);

  // Merge custom metadata with standard metadata
  const baseMetadata = getPdcaTaskMetadata(actualPhase, feature, actualOptions);
  const metadata = {
    ...baseMetadata,
    ...(actualOptions.metadata || {})
  };

  const phaseInfo = PDCA_PHASES[actualPhase.toLowerCase()] || PDCA_PHASES.do;

  // Generate unique task ID for tracking
  const taskId = `${actualPhase}-${feature}-${Date.now()}`;

  // v1.4.7 FR-02: Save Task ID for session persistence
  savePdcaTaskId(feature, actualPhase, taskId, {
    iteration: actualOptions.iteration
  });

  // v1.4.7 FR-07: blockedBy handling using Task ID instead of subject string
  let blockedBy = actualOptions.blockedBy ? [actualOptions.blockedBy] : [];
  if (blockedBy.length === 0 && classification === 'major_feature') {
    const prevPhase = getPreviousPdcaPhase(actualPhase);
    if (prevPhase) {
      // Try to get Task ID first, fallback to subject string
      const prevTaskId = getPdcaTaskId(feature, prevPhase);
      if (prevTaskId) {
        blockedBy = [prevTaskId];
      } else {
        blockedBy = [generatePdcaTaskSubject(prevPhase, feature)];
      }
    }
  }

  const taskGuidance = {
    action: 'TaskCreate',
    taskId,
    subject,
    description,
    metadata,
    blockedBy,
    activeForm: `${phaseInfo.emoji || ''} ${actualPhase} phase for ${feature}`
  };

  debugLog('TaskSystem', 'Task guidance generated', {
    feature,
    phase: actualPhase,
    classification,
    hasBlocker: blockedBy.length > 0,
    taskId
  });

  return taskGuidance;
}

// ============================================================
// 11. Debug Logging (v1.4.0 - Hooks Reliability)
// ============================================================

/**
 * Debug log paths by platform
 */
const DEBUG_LOG_PATHS = {
  claude: process.platform === 'win32'
    ? path.join(process.env.TEMP || require('os').tmpdir(), 'bkit-hook-debug.log')
    : '/tmp/bkit-hook-debug.log',
  gemini: process.platform === 'win32'
    ? path.join(process.env.TEMP || require('os').tmpdir(), 'bkit-hook-debug-gemini.log')
    : '/tmp/bkit-hook-debug-gemini.log',
  unknown: process.platform === 'win32'
    ? path.join(process.env.TEMP || require('os').tmpdir(), 'bkit-hook-debug.log')
    : '/tmp/bkit-hook-debug.log'
};

/**
 * Get debug log file path based on platform
 * @returns {string} Full path to debug log file
 */
function getDebugLogPath() {
  return DEBUG_LOG_PATHS[BKIT_PLATFORM] || DEBUG_LOG_PATHS.unknown;
}

/**
 * Debug log to temporary file
 * Only writes when BKIT_DEBUG environment variable is set to 'true'
 * @param {string} category - Log category (SessionStart, PreToolUse, Agent:name:Stop, etc.)
 * @param {string} message - Log message
 * @param {Object} data - Optional structured data
 */
function debugLog(category, message, data = {}) {
  // v1.4.0: Only log when BKIT_DEBUG is enabled (default: disabled for production)
  if (process.env.BKIT_DEBUG !== 'true') return;

  try {
    const logPath = getDebugLogPath();
    const timestamp = new Date().toISOString();
    const dataStr = Object.keys(data).length > 0
      ? `, ${JSON.stringify(data)}`
      : '';
    const logLine = `[${timestamp}] [${category}] ${message}${dataStr}\n`;

    fs.appendFileSync(logPath, logLine);
  } catch (e) {
    // Fail silently - logging should never break the hook
  }
}

// ============================================================
// 12. PDCA Status Management (v1.4.0 P4 - Schema v2.0)
// ============================================================

/**
 * PDCA Status file path
 */
const PDCA_STATUS_PATH = path.join(PROJECT_DIR, 'docs/.pdca-status.json');

/**
 * v2.0 Schema: Default initial status
 */
function createInitialStatusV2() {
  const now = new Date().toISOString();
  return {
    version: "2.0",
    lastUpdated: now,

    // v2.0: Multi-feature support
    activeFeatures: [],
    primaryFeature: null,

    // Feature-specific status
    features: {},

    // v2.0: Pipeline status
    pipeline: {
      currentPhase: 1,
      level: 'Dynamic',  // Default level
      phaseHistory: []
    },

    // v2.0: Session context
    session: {
      startedAt: now,
      onboardingCompleted: false,
      lastActivity: now
    },

    // History (kept from v1.0)
    history: []
  };
}

/**
 * Migrate v1.0 schema to v2.0
 * @param {Object} oldStatus - v1.0 status object
 * @returns {Object} v2.0 status object
 */
function migrateStatusToV2(oldStatus) {
  const now = new Date().toISOString();

  // Start with v2.0 defaults
  const newStatus = createInitialStatusV2();

  // Migrate features
  if (oldStatus.features) {
    newStatus.features = oldStatus.features;

    // Enhance each feature with v2.0 fields
    for (const [name, feat] of Object.entries(newStatus.features)) {
      if (!feat.requirements) feat.requirements = [];
      if (!feat.documents) feat.documents = {};
      if (!feat.timestamps) {
        feat.timestamps = {
          started: feat.startedAt || now,
          lastUpdated: feat.updatedAt || now
        };
      }
    }

    // Set active features from existing features
    newStatus.activeFeatures = Object.keys(newStatus.features).filter(
      f => newStatus.features[f].phase !== 'completed'
    );
  }

  // Migrate current feature
  if (oldStatus.currentFeature) {
    newStatus.primaryFeature = oldStatus.currentFeature;
    if (!newStatus.activeFeatures.includes(oldStatus.currentFeature)) {
      newStatus.activeFeatures.push(oldStatus.currentFeature);
    }
  }

  // Migrate pipeline phase
  if (oldStatus.currentPhase) {
    newStatus.pipeline.currentPhase = oldStatus.currentPhase;
  }

  // Keep history
  if (oldStatus.history) {
    newStatus.history = oldStatus.history;
  }

  // Update timestamps
  newStatus.lastUpdated = now;
  newStatus.session.lastActivity = now;

  debugLog('PDCA', 'Migrated status from v1.0 to v2.0');

  return newStatus;
}

/**
 * Initialize PDCA status file if not exists
 * Creates docs/.pdca-status.json with v2.0 schema
 */
function initPdcaStatusIfNotExists() {
  if (fs.existsSync(PDCA_STATUS_PATH)) return;

  // Ensure docs directory exists
  const docsDir = path.dirname(PDCA_STATUS_PATH);
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
  }

  const initialStatus = createInitialStatusV2();

  fs.writeFileSync(PDCA_STATUS_PATH, JSON.stringify(initialStatus, null, 2));
  _cache.set('pdca-status', initialStatus);
  debugLog('PDCA', 'Status file initialized (v2.0)', { path: PDCA_STATUS_PATH });
}

/**
 * Get current PDCA status with caching and auto-migration
 * @param {boolean} forceRefresh - Skip cache and read from file
 * @returns {Object|null} Full status object (v2.0) or null if not exists
 */
function getPdcaStatusFull(forceRefresh = false) {
  try {
    // Check cache first (unless force refresh)
    if (!forceRefresh) {
      const cached = _cache.get('pdca-status', 3000);  // 3 second TTL
      if (cached) return cached;
    }

    if (!fs.existsSync(PDCA_STATUS_PATH)) return null;

    let status = JSON.parse(fs.readFileSync(PDCA_STATUS_PATH, 'utf8'));

    // Auto-migrate v1.0 to v2.0
    if (!status.version || status.version === "1.0") {
      status = migrateStatusToV2(status);
      // Save migrated status
      savePdcaStatus(status);
    }

    // Cache the result
    _cache.set('pdca-status', status);

    return status;
  } catch (e) {
    debugLog('PDCA', 'Failed to read status', { error: e.message });
    return null;
  }
}

/**
 * Save PDCA status to file and update cache
 * @param {Object} status - Status object to save
 */
function savePdcaStatus(status) {
  try {
    status.lastUpdated = new Date().toISOString();
    if (status.session) {
      status.session.lastActivity = status.lastUpdated;
    }

    fs.writeFileSync(PDCA_STATUS_PATH, JSON.stringify(status, null, 2));
    _cache.set('pdca-status', status);
    debugLog('PDCA', 'Status saved', { version: status.version });
  } catch (e) {
    debugLog('PDCA', 'Failed to save status', { error: e.message });
  }
}

/**
 * Load PDCA status (alias for backward compatibility)
 * @returns {Object|null}
 */
function loadPdcaStatus() {
  return getPdcaStatusFull();
}

/**
 * Get status for specific feature
 * @param {string} feature - Feature name
 * @returns {Object|null} Feature status or null
 */
function getFeatureStatus(feature) {
  const status = getPdcaStatusFull();
  if (!status || !status.features) return null;
  return status.features[feature] || null;
}

/**
 * Update PDCA status for a feature (v2.0 enhanced)
 * FR-05: Returns result object for caller to check success/failure
 * @param {string} feature - Feature name
 * @param {string} phase - PDCA phase (plan|design|do|check|act|completed)
 * @param {Object} data - Additional data (matchRate, docPath, requirements, fulfillment, etc.)
 * @returns {{ success: boolean, feature?: string, phase?: string, error?: string }}
 */
function updatePdcaStatus(feature, phase, data = {}) {
  try {
    initPdcaStatusIfNotExists();

    const status = getPdcaStatusFull() || createInitialStatusV2();
    const phaseNumber = PDCA_PHASES[phase.toLowerCase()]?.order || 3;
    const now = new Date().toISOString();

    // v2.0: Ensure required structures exist
    if (!status.activeFeatures) status.activeFeatures = [];
    if (!status.features) status.features = {};
    if (!status.pipeline) status.pipeline = { currentPhase: 1, level: 'Dynamic', phaseHistory: [] };
    if (!status.session) status.session = { startedAt: now, onboardingCompleted: false, lastActivity: now };
    if (!status.history) status.history = [];

    // Update or create feature status (v2.0 enhanced structure)
    if (!status.features[feature]) {
      status.features[feature] = {
        phase: phase.toLowerCase(),
        phaseNumber,
        matchRate: null,
        iterationCount: 0,
        requirements: [],
        documents: {},
        timestamps: {
          started: now,
          lastUpdated: now
        }
      };
    }

    // Update feature fields
    const feat = status.features[feature];
    feat.phase = phase.toLowerCase();
    feat.phaseNumber = phaseNumber;
    feat.timestamps.lastUpdated = now;

    // Merge additional data
    if (data.matchRate !== undefined) feat.matchRate = data.matchRate;
    if (data.iterationCount !== undefined) feat.iterationCount = data.iterationCount;
    if (data.requirements) feat.requirements = data.requirements;
    if (data.fulfillment) feat.fulfillment = data.fulfillment;

    // Track document paths
    if (data.planDoc) feat.documents.plan = data.planDoc;
    if (data.designDoc) feat.documents.design = data.designDoc;
    if (data.analysisDoc) feat.documents.analysis = data.analysisDoc;
    if (data.reportDoc) feat.documents.report = data.reportDoc;

    // Mark completion timestamp
    if (phase === 'completed') {
      feat.timestamps.completed = now;
    }

    // v2.0: Update activeFeatures list
    if (phase === 'completed') {
      status.activeFeatures = status.activeFeatures.filter(f => f !== feature);
    } else if (!status.activeFeatures.includes(feature)) {
      status.activeFeatures.push(feature);
    }

    // v2.0: Update primaryFeature
    status.primaryFeature = feature;

    // v2.0: Update session activity
    status.session.lastActivity = now;
    status.lastUpdated = now;

    // Add history entry
    const historyEntry = {
      timestamp: now,
      feature,
      phase: phase.toLowerCase(),
      action: data.matchRate ? 'analyzed' : (phase === 'completed' ? 'completed' : 'updated')
    };

    if (data.matchRate || data.iterationCount || data.fulfillment) {
      historyEntry.details = {};
      if (data.matchRate) historyEntry.details.matchRate = data.matchRate;
      if (data.iterationCount) historyEntry.details.iteration = data.iterationCount;
      if (data.fulfillment) historyEntry.details.fulfillmentScore = data.fulfillment.score;
    }

    status.history.push(historyEntry);

    // Keep history to last 100 entries
    if (status.history.length > 100) {
      status.history = status.history.slice(-100);
    }

    // Save using savePdcaStatus (updates cache)
    savePdcaStatus(status);
    debugLog('PDCA', `Status updated (v2.0): ${feature} ‚Üí ${phase}`, data);

    // FR-05: Return success result
    return { success: true, feature, phase };

  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e);
    debugLog('PDCA', 'Failed to update status', { error: errorMsg });
    // FR-05: Return failure result with error details
    return { success: false, feature, phase, error: errorMsg };
  }
}

/**
 * Add entry to PDCA history
 * @param {Object} entry - History entry (without timestamp)
 */
function addPdcaHistory(entry) {
  try {
    const status = getPdcaStatusFull();
    if (!status) return;

    const now = new Date().toISOString();
    status.history.push({
      timestamp: now,
      ...entry
    });

    // Keep history to last 100 entries
    if (status.history.length > 100) {
      status.history = status.history.slice(-100);
    }

    status.lastUpdated = now;
    fs.writeFileSync(PDCA_STATUS_PATH, JSON.stringify(status, null, 2));

  } catch (e) {
    debugLog('PDCA', 'Failed to add history', { error: e.message });
  }
}

/**
 * Mark feature as completed
 * @param {string} feature - Feature name
 */
function completePdcaFeature(feature) {
  updatePdcaStatus(feature, 'completed', {
    completedAt: new Date().toISOString()
  });
}

/**
 * Extract feature name from multiple sources
 * Priority: 1) explicit param, 2) agent output, 3) file path, 4) current status
 * @param {Object} sources - Possible sources for feature name
 * @returns {string} Feature name or empty string
 */
function extractFeatureFromContext(sources = {}) {
  // 1. Explicit parameter
  if (sources.explicit && typeof sources.explicit === 'string') {
    return sources.explicit;
  }

  // 2. Agent output (parse from string)
  if (sources.agentOutput && typeof sources.agentOutput === 'string') {
    const patterns = [
      /feature[:\s]+['"]?(\w[\w-]*)['"]?/i,
      /analyzing\s+['"]?(\w[\w-]*)['"]?/i,
      /for\s+['"]?(\w[\w-]*)['"]?\s+feature/i
    ];
    for (const pattern of patterns) {
      const match = sources.agentOutput.match(pattern);
      if (match && match[1]) return match[1];
    }
  }

  // 3. File path
  if (sources.filePath && typeof sources.filePath === 'string') {
    const extracted = extractFeature(sources.filePath);
    if (extracted) return extracted;
  }

  // 4. Current status
  if (sources.currentStatus && sources.currentStatus.currentFeature) {
    return sources.currentStatus.currentFeature;
  }

  return '';
}

// ============================================================
// 12-B. v1.4.0 Multi-Feature Context Management (P4-005)
// ============================================================

/**
 * Set the primary active feature
 * @param {string} feature - Feature name to set as primary
 * @returns {boolean} Success status
 */
function setActiveFeature(feature) {
  if (!feature || typeof feature !== 'string') {
    debugLog('PDCA', 'setActiveFeature: Invalid feature name');
    return false;
  }

  try {
    const status = getPdcaStatusFull(true);

    // Add to activeFeatures if not present
    if (!status.activeFeatures.includes(feature)) {
      status.activeFeatures.push(feature);
    }

    // Set as primary
    status.primaryFeature = feature;
    status.lastUpdated = new Date().toISOString();

    // Update session activity
    if (status.session) {
      status.session.lastActivity = status.lastUpdated;
    }

    savePdcaStatus(status);
    debugLog('PDCA', 'Primary feature set', { feature });
    return true;
  } catch (e) {
    debugLog('PDCA', 'setActiveFeature failed', { error: e.message });
    return false;
  }
}

/**
 * Add a feature to the active features list
 * @param {string} feature - Feature name to add
 * @param {boolean} setAsPrimary - Whether to set as primary (default: false)
 * @returns {boolean} Success status
 */
function addActiveFeature(feature, setAsPrimary = false) {
  if (!feature || typeof feature !== 'string') {
    debugLog('PDCA', 'addActiveFeature: Invalid feature name');
    return false;
  }

  try {
    const status = getPdcaStatusFull(true);

    // Add to activeFeatures if not present
    if (!status.activeFeatures.includes(feature)) {
      status.activeFeatures.push(feature);
    }

    // Initialize feature structure if not exists
    if (!status.features[feature]) {
      const now = new Date().toISOString();
      status.features[feature] = {
        phase: 'plan',
        createdAt: now,
        lastUpdated: now,
        documents: {},
        iterations: { count: 0, history: [] },
        requirements: { total: 0, fulfilled: 0, items: [] }
      };
    }

    // Set as primary if requested or no primary exists
    if (setAsPrimary || !status.primaryFeature) {
      status.primaryFeature = feature;
    }

    status.lastUpdated = new Date().toISOString();
    savePdcaStatus(status);
    debugLog('PDCA', 'Feature added to active list', { feature, setAsPrimary });
    return true;
  } catch (e) {
    debugLog('PDCA', 'addActiveFeature failed', { error: e.message });
    return false;
  }
}

/**
 * Remove a feature from the active features list
 * @param {string} feature - Feature name to remove
 * @returns {boolean} Success status
 */
function removeActiveFeature(feature) {
  if (!feature || typeof feature !== 'string') {
    debugLog('PDCA', 'removeActiveFeature: Invalid feature name');
    return false;
  }

  try {
    const status = getPdcaStatusFull(true);

    // Remove from activeFeatures
    status.activeFeatures = status.activeFeatures.filter(f => f !== feature);

    // If removed feature was primary, select new primary
    if (status.primaryFeature === feature) {
      status.primaryFeature = status.activeFeatures.length > 0
        ? status.activeFeatures[0]
        : null;
    }

    status.lastUpdated = new Date().toISOString();
    savePdcaStatus(status);
    debugLog('PDCA', 'Feature removed from active list', { feature, newPrimary: status.primaryFeature });
    return true;
  } catch (e) {
    debugLog('PDCA', 'removeActiveFeature failed', { error: e.message });
    return false;
  }
}

/**
 * Get all active features
 * @returns {Object} Active features info with primary indicator
 */
function getActiveFeatures() {
  try {
    const status = getPdcaStatusFull();
    return {
      activeFeatures: status.activeFeatures || [],
      primaryFeature: status.primaryFeature || null,
      features: Object.entries(status.features || {})
        .filter(([name]) => (status.activeFeatures || []).includes(name))
        .reduce((acc, [name, data]) => {
          acc[name] = {
            phase: data.phase,
            matchRate: data.matchRate,
            lastUpdated: data.lastUpdated,
            isPrimary: name === status.primaryFeature
          };
          return acc;
        }, {})
    };
  } catch (e) {
    debugLog('PDCA', 'getActiveFeatures failed', { error: e.message });
    return { activeFeatures: [], primaryFeature: null, features: {} };
  }
}

/**
 * Switch to a different feature context
 * @param {string} feature - Feature name to switch to
 * @returns {Object} Switch result with feature context
 */
function switchFeatureContext(feature) {
  if (!feature || typeof feature !== 'string') {
    return { success: false, error: 'Invalid feature name' };
  }

  try {
    const status = getPdcaStatusFull(true);

    // Check if feature exists
    if (!status.features[feature]) {
      return {
        success: false,
        error: `Feature '${feature}' not found. Use addActiveFeature() to create it.`
      };
    }

    // Add to active if not present
    if (!status.activeFeatures.includes(feature)) {
      status.activeFeatures.push(feature);
    }

    // Set as primary
    const previousPrimary = status.primaryFeature;
    status.primaryFeature = feature;
    status.lastUpdated = new Date().toISOString();

    // Update session
    if (status.session) {
      status.session.lastActivity = status.lastUpdated;
    }

    savePdcaStatus(status);

    // Return context info
    const featureData = status.features[feature];
    return {
      success: true,
      previousFeature: previousPrimary,
      currentFeature: feature,
      context: {
        phase: featureData.phase,
        matchRate: featureData.matchRate,
        iterationCount: featureData.iterations?.count || 0,
        documents: featureData.documents || {},
        requirements: featureData.requirements || {}
      }
    };
  } catch (e) {
    debugLog('PDCA', 'switchFeatureContext failed', { error: e.message });
    return { success: false, error: e.message };
  }
}

// ============================================================
// 13. v1.4.0 Intent Detection Functions (8-Language Support)
// ============================================================

/**
 * Detect new feature intent from user message
 * Supports 8 languages: EN, KO, JA, ZH, ES, FR, DE, IT
 * @param {string} userMessage - User input message
 * @returns {Object} IntentDetectionResult
 */
function detectNewFeatureIntent(userMessage) {
  if (!userMessage || typeof userMessage !== 'string') {
    return { isNewFeature: false, featureName: null, confidence: 0, intentType: 'unknown', extractedKeywords: [] };
  }

  const msg = userMessage.toLowerCase().trim();

  // 8Í∞ú Ïñ∏Ïñ¥ ÏßÄÏõê Ìå®ÌÑ¥
  const patterns = {
    en: [
      { regex: /(create|implement|add|build|develop)\s+(?:a\s+)?(.+?)\s*(feature|functionality|module|system)/i, type: 'create' },
      { regex: /(make|write)\s+(?:a\s+)?(.+?)\s*(for|that|which)/i, type: 'create' },
      { regex: /new\s+(.+?)\s*(feature|module|component)/i, type: 'create' }
    ],
    ko: [
      { regex: /(.+?)(Í∏∞Îä•|feature)\s*(ÎßåÎì§Ïñ¥|Íµ¨ÌòÑ|Ï∂îÍ∞Ä|Í∞úÎ∞ú|ÏûëÏÑ±)/i, type: 'create' },
      { regex: /(.+?)\s*(ÏûëÏÑ±|ÏÉùÏÑ±|ÎßåÎì§)\s*Ìï¥\s*Ï§ò/i, type: 'create' },
      { regex: /(.+?)(ÏùÑ|Î•º)\s*(Íµ¨ÌòÑ|Í∞úÎ∞ú|Ï∂îÍ∞Ä)/i, type: 'create' },
      { regex: /ÏÉà\s*(.+?)\s*(Í∏∞Îä•|Î™®Îìà)/i, type: 'create' }
    ],
    ja: [
      { regex: /(.+?)(Ê©üËÉΩ|„Éï„Ç£„Éº„ÉÅ„É£„Éº)\s*(‰Ωú„Å£„Å¶|ÂÆüË£Ö|ËøΩÂä†)/i, type: 'create' },
      { regex: /(.+?)(„Çí)?(‰ΩúÊàê|ÂÆüË£Ö|ÈñãÁô∫)(„Åó„Å¶|„Åô„Çã)/i, type: 'create' },
      { regex: /Êñ∞„Åó„ÅÑ\s*(.+?)\s*(Ê©üËÉΩ|„É¢„Ç∏„É•„Éº„É´)/i, type: 'create' }
    ],
    zh: [
      { regex: /(ÂàõÂª∫|ÂÆûÁé∞|Ê∑ªÂä†|ÂºÄÂèë)(.+?)(ÂäüËÉΩ|Ê®°Âùó)/i, type: 'create' },
      { regex: /(ÂÅö|ÂÜô|Âª∫)(.+?)(ÂäüËÉΩ|Á≥ªÁªü)/i, type: 'create' },
      { regex: /Êñ∞ÁöÑ?\s*(.+?)\s*(ÂäüËÉΩ|Ê®°Âùó)/i, type: 'create' }
    ],
    es: [
      { regex: /(crear|implementar|a√±adir|desarrollar)\s+(?:una?\s+)?(.+?)\s*(funci√≥n|funcionalidad|m√≥dulo)/i, type: 'create' },
      { regex: /(hacer|escribir)\s+(?:una?\s+)?(.+)/i, type: 'create' }
    ],
    fr: [
      { regex: /(cr√©er|impl√©menter|ajouter|d√©velopper)\s+(?:une?\s+)?(.+?)\s*(fonction|fonctionnalit√©|module)/i, type: 'create' },
      { regex: /(faire|√©crire)\s+(?:une?\s+)?(.+)/i, type: 'create' }
    ],
    de: [
      { regex: /(erstellen|implementieren|hinzuf√ºgen|entwickeln)\s+(?:eine?n?\s+)?(.+?)\s*(Funktion|Funktionalit√§t|Modul)/i, type: 'create' },
      { regex: /(machen|schreiben)\s+(?:eine?n?\s+)?(.+)/i, type: 'create' }
    ],
    it: [
      { regex: /(creare|implementare|aggiungere|sviluppare)\s+(?:una?\s+)?(.+?)\s*(funzione|funzionalit√†|modulo)/i, type: 'create' },
      { regex: /(fare|scrivere)\s+(?:una?\s+)?(.+)/i, type: 'create' }
    ]
  };

  // Bug fix / Modify patterns
  const modifyPatterns = [
    /fix\s+(.+)/i, /ÏàòÏ†ï|Í≥†Ï≥ê|Î≤ÑÍ∑∏/i, /‰øÆÊ≠£|„Éê„Ç∞/i, /‰øÆÂ§ç|bug/i,
    /corregir|arreglar/i, /corriger|r√©parer/i, /reparieren|korrigieren/i, /correggere|riparare/i
  ];

  // Check for modify intent first
  for (const pattern of modifyPatterns) {
    if (pattern.test(msg)) {
      return {
        isNewFeature: false,
        featureName: null,
        confidence: 0.7,
        intentType: 'fix',
        extractedKeywords: []
      };
    }
  }

  // Check for new feature patterns
  for (const lang of Object.keys(patterns)) {
    for (const { regex, type } of patterns[lang]) {
      const match = userMessage.match(regex);
      if (match) {
        // Extract feature name (usually in capture group 1 or 2)
        let featureName = match[2] || match[1] || '';
        featureName = featureName.trim().replace(/['"]/g, '').toLowerCase();

        // Clean up common words
        featureName = featureName.replace(/\s*(the|a|an|Ïù¥|Í∞Ä|ÏùÑ|Î•º|„ÅÆ|„Çí)\s*/gi, ' ').trim();

        // Convert to kebab-case
        featureName = featureName.replace(/\s+/g, '-').replace(/[^a-z0-9Í∞Ä-Ìû£„ÅÅ-„Çì„Ç°-„É≥‰∏Ä-Èæ•\-]/gi, '');

        if (featureName && featureName.length > 1) {
          return {
            isNewFeature: true,
            featureName: featureName,
            confidence: 0.85 + (lang === 'en' ? 0.1 : 0),
            intentType: type,
            extractedKeywords: [featureName],
            detectedLanguage: lang
          };
        }
      }
    }
  }

  return {
    isNewFeature: false,
    featureName: null,
    confidence: 0,
    intentType: 'unknown',
    extractedKeywords: []
  };
}

/**
 * Match implicit agent trigger from user message
 * @param {string} userMessage - User input
 * @returns {Object|null} { agent, confidence, pattern } or null
 */
function matchImplicitAgentTrigger(userMessage) {
  if (!userMessage || typeof userMessage !== 'string') return null;

  const msg = userMessage.toLowerCase();

  // 8Í∞ú Ïñ∏Ïñ¥ ÏßÄÏõê ÏóêÏù¥Ï†ÑÌä∏ Ìä∏Î¶¨Í±∞ Ìå®ÌÑ¥
  const implicitPatterns = {
    'bkit:gap-detector': {
      patterns: [
        /is this (right|correct)/i, /does this match/i, /verify/i, /check/i,
        /ÎßûÏïÑ\??/, /Í¥úÏ∞ÆÏïÑ\??/, /ÏÑ§Í≥ÑÎåÄÎ°ú/, /Í≤ÄÏ¶ù/, /ÌôïÏù∏/,
        /Ê≠£„Åó„ÅÑ/, /Âêà„Å£„Å¶„Çã/, /„Åì„Çå„Åß(„ÅÑ„ÅÑ|Â§ß‰∏àÂ§´)/,
        /ÂØπÂêó/, /ÂØπ‰∏çÂØπ/, /Ê≠£Á°ÆÂêó/,
        /est√° (bien|correcto)/i, /es correcto/i,
        /c'est (bon|correct)/i, /est-ce correct/i,
        /ist (das|es) (richtig|korrekt)/i,
        /√® (giusto|corretto)/i, /va bene/i
      ],
      contextRequired: ['design', 'implementation']
    },
    'bkit:code-analyzer': {
      patterns: [
        /any (issues|problems)/i, /something (wrong|off)/i, /analyze/i, /quality/i,
        /Ïù¥ÏÉÅÌï¥/, /Î≠îÍ∞Ä.*Ïù¥ÏÉÅ/, /Î¨∏Ï†ú.*Ïûà/, /Î∂ÑÏÑù/, /ÌíàÏßà/,
        /„Åä„Åã„Åó„ÅÑ/, /ÂïèÈ°å/, /ÂìÅË≥™/,
        /ÊúâÈóÆÈ¢ò/, /Ë¥®Èáè/, /Â•áÊÄ™/,
        /hay (problemas|errores)/i, /algo (mal|raro)/i,
        /il y a (des probl√®mes|des erreurs)/i,
        /gibt es (Probleme|Fehler)/i,
        /ci sono (problemi|errori)/i
      ],
      contextRequired: ['code']
    },
    'bkit:pdca-iterator': {
      patterns: [
        /make.*better/i, /improve/i, /fix (this|it)/i, /iterate/i, /auto.?fix/i,
        /Í≥†Ï≥ê/, /Îçî.*Ï¢ãÍ≤å/, /Í∞úÏÑ†/, /Î∞òÎ≥µ/,
        /Áõ¥„Åó„Å¶/, /‰øÆÊ≠£/, /ÊîπÂñÑ/,
        /ÊîπËøõ/, /‰øÆÂ§ç/, /ÊîπÂñÑ/,
        /mejorar/i, /arreglar/i, /corregir/i,
        /am√©liorer/i, /corriger/i, /r√©parer/i,
        /verbessern/i, /reparieren/i, /korrigieren/i,
        /migliorare/i, /correggere/i, /riparare/i
      ],
      contextRequired: ['check', 'act']
    },
    'bkit:report-generator': {
      patterns: [
        /what did we/i, /status/i, /progress/i, /summary/i, /report/i,
        /Î≠ê.*ÌñàÏñ¥/, /ÏßÑÌñâ.*ÏÉÅÌô©/, /ÏöîÏïΩ/, /Î≥¥Í≥†ÏÑú/,
        /‰Ωï„Çí„Åó„Åü/, /ÈÄ≤Êçó/, /Áä∂Ê≥Å/, /Â†±Âëä/,
        /ÂÅö‰∫Ü‰ªÄ‰πà/, /ËøõÂ∫¶/, /Áä∂ÊÄÅ/, /Êä•Âëä/,
        /qu√© hicimos/i, /estado/i, /progreso/i,
        /qu'avons-nous fait/i, /statut/i, /progr√®s/i,
        /was haben wir/i, /Status/i, /Fortschritt/i,
        /cosa abbiamo fatto/i, /stato/i, /progresso/i
      ],
      contextRequired: ['any']
    },
    'bkit:starter-guide': {
      patterns: [
        /help.*understand/i, /don't understand/i, /confused/i, /beginner/i,
        /Ïù¥Ìï¥.*Ïïà.*Îèº/, /ÏÑ§Î™ÖÌï¥/, /Ïñ¥Î†§Ïõå/, /Î™®Î•¥Í≤†/, /Ï¥àÎ≥¥/,
        /„Çè„Åã„Çâ„Å™„ÅÑ/, /Êïô„Åà„Å¶/, /Èõ£„Åó„ÅÑ/, /ÂàùÂøÉËÄÖ/,
        /‰∏çÊáÇ/, /‰∏çÊòéÁôΩ/, /Â§™Èöæ/, /Êñ∞Êâã/,
        /no entiendo/i, /explica/i, /dif√≠cil/i, /principiante/i,
        /je ne comprends pas/i, /explique/i, /difficile/i, /d√©butant/i,
        /verstehe nicht/i, /erkl√§re/i, /schwierig/i, /Anf√§nger/i,
        /non capisco/i, /spiega/i, /difficile/i, /principiante/i
      ],
      contextRequired: ['any']
    }
  };

  for (const [agent, config] of Object.entries(implicitPatterns)) {
    for (const pattern of config.patterns) {
      if (pattern.test(msg)) {
        return {
          agent,
          confidence: 0.85,
          pattern: pattern.toString(),
          contextRequired: config.contextRequired
        };
      }
    }
  }

  return null;
}

/**
 * Match implicit skill trigger from user message
 * Supports all 18 bkit skills
 * @param {string} userMessage - User input
 * @returns {Object|null} { skill, confidence, pattern } or null
 */
function matchImplicitSkillTrigger(userMessage) {
  if (!userMessage || typeof userMessage !== 'string') return null;

  const msg = userMessage.toLowerCase();

  // 18Í∞ú Ïä§ÌÇ¨ Ï†ÑÏ≤¥ Ìä∏Î¶¨Í±∞ Ìå®ÌÑ¥
  const implicitSkillPatterns = {
    // === Level Skills (5) ===
    'starter': {
      patterns: [
        /static (website|site)/i, /portfolio/i, /landing page/i, /beginner/i, /first (website|project)/i,
        /Ï†ïÏ†Å\s*(Ïõπ|ÏÇ¨Ïù¥Ìä∏)/, /Ìè¨Ìä∏Ìè¥Î¶¨Ïò§/, /ÎûúÎî©/, /Ï¥àÎ≥¥/, /Ï≤´\s*(Ïõπ|ÌîÑÎ°úÏ†ùÌä∏)/,
        /ÈùôÁöÑ(„Çµ„Ç§„Éà|„Ç¶„Çß„Éñ)/, /„Éù„Éº„Éà„Éï„Ç©„É™„Ç™/, /ÂàùÂøÉËÄÖ/, /Âàù„ÇÅ„Å¶/,
        /ÈùôÊÄÅ(ÁΩëÁ´ô|ÁΩëÈ°µ)/, /‰ΩúÂìÅÈõÜ/, /ÂàùÂ≠¶ËÄÖ/, /Êñ∞Êâã/
      ],
      excludePatterns: [/backend/i, /database/i, /authentication/i, /login/i, /api/i]
    },
    'dynamic': {
      patterns: [
        /fullstack/i, /full-stack/i, /BaaS/i, /login (feature|system)/i, /authentication/i, /database/i,
        /ÌíÄÏä§ÌÉù/, /Î°úÍ∑∏Ïù∏\s*Í∏∞Îä•/, /Ïù∏Ï¶ù/, /ÌöåÏõêÍ∞ÄÏûÖ/, /Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§/,
        /„Éï„É´„Çπ„Çø„ÉÉ„ÇØ/, /„É≠„Ç∞„Ç§„É≥Ê©üËÉΩ/, /Ë™çË®º/, /„Éá„Éº„Çø„Éô„Éº„Çπ/,
        /ÂÖ®Ê†à/, /ÁôªÂΩïÂäüËÉΩ/, /Ë∫´‰ªΩÈ™åËØÅ/, /Êï∞ÊçÆÂ∫ì/
      ],
      excludePatterns: [/kubernetes/i, /terraform/i, /microservice/i, /k8s/i]
    },
    'enterprise': {
      patterns: [
        /microservice/i, /kubernetes/i, /k8s/i, /terraform/i, /AWS/i, /enterprise/i,
        /ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§/, /Ïø†Î≤ÑÎÑ§Ìã∞Ïä§/, /ÌÖåÎùºÌèº/, /ÏóîÌÑ∞ÌîÑÎùºÏù¥Ï¶à/,
        /„Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„Çπ/, /„ÇØ„Éô„É´„Éç„ÉÜ„Çπ/, /„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫/,
        /ÂæÆÊúçÂä°/, /‰ºÅ‰∏öÁ∫ß/, /‰∫ëÊû∂ÊûÑ/
      ],
      excludePatterns: []
    },
    'mobile-app': {
      patterns: [
        /mobile app/i, /react native/i, /flutter/i, /expo/i, /iOS app/i, /android app/i,
        /Î™®Î∞îÏùº\s*Ïï±/, /Î¶¨Ïï°Ìä∏\s*ÎÑ§Ïù¥Ìã∞Î∏å/, /ÌîåÎü¨ÌÑ∞/, /ÏïÑÏù¥Ìè∞\s*Ïï±/, /ÏïàÎìúÎ°úÏù¥Îìú\s*Ïï±/,
        /„É¢„Éê„Ç§„É´„Ç¢„Éó„É™/, /„É™„Ç¢„ÇØ„Éà„Éç„Ç§„ÉÜ„Ç£„Éñ/, /„Éï„É©„ÉÉ„Çø„Éº/,
        /ÁßªÂä®Â∫îÁî®/, /ÊâãÊú∫Â∫îÁî®/
      ],
      excludePatterns: []
    },
    'desktop-app': {
      patterns: [
        /desktop app/i, /electron/i, /tauri/i, /mac app/i, /windows app/i,
        /Îç∞Ïä§ÌÅ¨ÌÜ±\s*Ïï±/, /ÏùºÎ†âÌä∏Î°†/, /ÌÉÄÏö∞Î¶¨/, /Îß•\s*Ïï±/, /ÏúàÎèÑÏö∞\s*Ïï±/,
        /„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„Ç¢„Éó„É™/, /„Ç®„É¨„ÇØ„Éà„É≠„É≥/,
        /Ê°åÈù¢Â∫îÁî®/, /Ê°åÈù¢Á®ãÂ∫è/
      ],
      excludePatterns: []
    },

    // === Core Skills (4) ===
    'zero-script-qa': {
      patterns: [
        /zero script qa/i, /log.based test/i, /docker log/i, /no test script/i,
        /Ï†úÎ°ú\s*Ïä§ÌÅ¨Î¶ΩÌä∏/, /Î°úÍ∑∏\s*Í∏∞Î∞ò\s*ÌÖåÏä§Ìä∏/, /ÎèÑÏª§\s*Î°úÍ∑∏/,
        /„Çº„É≠„Çπ„ÇØ„É™„Éó„Éà/, /„É≠„Ç∞„Éô„Éº„Çπ/, /Docker„É≠„Ç∞/,
        /Èõ∂ËÑöÊú¨/, /Êó•ÂøóÊµãËØï/, /DockerÊó•Âøó/
      ],
      excludePatterns: []
    },
    'bkit-templates': {
      patterns: [
        /template/i, /plan document/i, /design document/i, /analysis document/i,
        /ÌÖúÌîåÎ¶ø/, /Í≥ÑÌöçÏÑú/, /ÏÑ§Í≥ÑÏÑú/, /Î∂ÑÏÑùÏÑú/, /Î≥¥Í≥†ÏÑú/,
        /„ÉÜ„É≥„Éó„É¨„Éº„Éà/, /Ë®àÁîªÊõ∏/, /Ë®≠Ë®àÊõ∏/, /ÂàÜÊûêÊõ∏/,
        /Ê®°Êùø/, /ËÆ°Âàí‰π¶/, /ËÆæËÆ°‰π¶/, /ÂàÜÊûêÊä•Âëä/
      ],
      excludePatterns: []
    },
    'bkit-rules': {
      patterns: [
        /bkit rule/i, /PDCA rule/i, /coding standard/i,
        /bkit\s*Í∑úÏπô/, /PDCA\s*Í∑úÏπô/, /ÏΩîÎî©\s*ÌëúÏ§Ä/,
        /„Éì„Éº„Ç≠„ÉÉ„Éà„É´„Éº„É´/, /PDCA„É´„Éº„É´/,
        /ÁºñÁ†ÅÊ†áÂáÜ/
      ],
      excludePatterns: []
    },
    'development-pipeline': {
      patterns: [
        /pipeline/i, /development order/i, /where.*start/i, /what.*first/i, /9.*(phase|stage)/i,
        /ÌååÏù¥ÌîÑÎùºÏù∏/, /Í∞úÎ∞ú\s*ÏàúÏÑú/, /Î≠êÎ∂ÄÌÑ∞/, /Ïñ¥ÎîîÏÑúÎ∂ÄÌÑ∞/, /ÏàúÏÑú/,
        /„Éë„Ç§„Éó„É©„Ç§„É≥/, /ÈñãÁô∫È†ÜÂ∫è/, /‰Ωï„Åã„Çâ/, /„Å©„Åì„Åã„Çâ/,
        /ÂºÄÂèëÊµÅÁ®ã/, /‰ªéÂì™ÈáåÂºÄÂßã/, /ÂºÄÂèëÈ°∫Â∫è/
      ],
      excludePatterns: []
    },

    // === Phase Skills (9) ===
    'phase-1-schema': {
      patterns: [
        /schema/i, /terminology/i, /data model/i, /entity/i, /phase.?1/i,
        /Ïä§ÌÇ§Îßà/, /Ïö©Ïñ¥/, /Îç∞Ïù¥ÌÑ∞\s*Î™®Îç∏/, /ÏóîÌã∞Ìã∞/,
        /„Çπ„Ç≠„Éº„Éû/, /Áî®Ë™û/, /„Éá„Éº„Çø„É¢„Éá„É´/,
        /Ê®°Âºè/, /ÊúØËØ≠/, /Êï∞ÊçÆÊ®°Âûã/
      ],
      excludePatterns: []
    },
    'phase-2-convention': {
      patterns: [
        /convention/i, /coding style/i, /naming rule/i, /code standard/i, /phase.?2/i,
        /Ïª®Î≤§ÏÖò/, /ÏΩîÎî©\s*Ïä§ÌÉÄÏùº/, /ÎÑ§Ïù¥Î∞ç\s*Í∑úÏπô/, /ÏΩîÎìú\s*ÌëúÏ§Ä/,
        /„Ç≥„É≥„Éô„É≥„Ç∑„Éß„É≥/, /„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çπ„Çø„Ç§„É´/, /ÂëΩÂêçË¶èÂâá/,
        /ÁºñÁ†ÅËßÑËåÉ/, /ÂëΩÂêçËßÑÂàô/, /‰ª£Á†ÅÊ†áÂáÜ/
      ],
      excludePatterns: []
    },
    'phase-3-mockup': {
      patterns: [
        /mockup/i, /prototype/i, /wireframe/i, /UI design/i, /phase.?3/i,
        /Î™©ÏóÖ/, /ÌîÑÎ°úÌÜ†ÌÉÄÏûÖ/, /ÏôÄÏù¥Ïñ¥ÌîÑÎ†àÏûÑ/, /UI\s*ÎîîÏûêÏù∏/,
        /„É¢„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó/, /„Éó„É≠„Éà„Çø„Ç§„Éó/, /„ÉØ„Ç§„É§„Éº„Éï„É¨„Éº„É†/,
        /ÂéüÂûã/, /Á∫øÊ°ÜÂõæ/, /UIËÆæËÆ°/
      ],
      excludePatterns: []
    },
    'phase-4-api': {
      patterns: [
        /API design/i, /REST API/i, /backend/i, /endpoint/i, /phase.?4/i,
        /API\s*ÏÑ§Í≥Ñ/, /Î∞±ÏóîÎìú/, /ÏóîÎìúÌè¨Ïù∏Ìä∏/,
        /APIË®≠Ë®à/, /„Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ/, /„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà/,
        /APIËÆæËÆ°/, /ÂêéÁ´Ø/, /Êé•Âè£/
      ],
      excludePatterns: []
    },
    'phase-5-design-system': {
      patterns: [
        /design system/i, /component library/i, /design token/i, /shadcn/i, /phase.?5/i,
        /ÎîîÏûêÏù∏\s*ÏãúÏä§ÌÖú/, /Ïª¥Ìè¨ÎÑåÌä∏\s*ÎùºÏù¥Î∏åÎü¨Î¶¨/, /ÎîîÏûêÏù∏\s*ÌÜ†ÌÅ∞/,
        /„Éá„Ç∂„Ç§„É≥„Ç∑„Çπ„ÉÜ„É†/, /„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„É©„Ç§„Éñ„É©„É™/,
        /ËÆæËÆ°Á≥ªÁªü/, /ÁªÑ‰ª∂Â∫ì/, /ËÆæËÆ°‰ª§Áâå/
      ],
      excludePatterns: []
    },
    'phase-6-ui-integration': {
      patterns: [
        /UI implementation/i, /API integration/i, /state management/i, /phase.?6/i,
        /UI\s*Íµ¨ÌòÑ/, /API\s*Ïó∞Îèô/, /ÏÉÅÌÉú\s*Í¥ÄÎ¶¨/,
        /UIÂÆüË£Ö/, /APIÈÄ£Êê∫/, /Áä∂ÊÖãÁÆ°ÁêÜ/,
        /UIÂÆûÁé∞/, /APIÈõÜÊàê/, /Áä∂ÊÄÅÁÆ°ÁêÜ/
      ],
      excludePatterns: []
    },
    'phase-7-seo-security': {
      patterns: [
        /SEO/i, /security/i, /meta tag/i, /XSS/i, /CSRF/i, /phase.?7/i,
        /Í≤ÄÏÉâ\s*ÏµúÏ†ÅÌôî/, /Î≥¥Ïïà/, /Î©îÌÉÄ\s*ÌÉúÍ∑∏/,
        /„Çª„Ç≠„É•„É™„ÉÜ„Ç£/, /„É°„Çø„Çø„Ç∞/,
        /ÊêúÁ¥¢‰ºòÂåñ/, /ÂÆâÂÖ®/, /ÂÖÉÊ†áÁ≠æ/
      ],
      excludePatterns: []
    },
    'phase-8-review': {
      patterns: [
        /code review/i, /architecture review/i, /quality check/i, /gap analysis/i, /phase.?8/i,
        /ÏΩîÎìú\s*Î¶¨Î∑∞/, /ÏïÑÌÇ§ÌÖçÏ≤ò\s*Î¶¨Î∑∞/, /ÌíàÏßà\s*Í≤ÄÏÇ¨/, /Í∞≠\s*Î∂ÑÏÑù/,
        /„Ç≥„Éº„Éâ„É¨„Éì„É•„Éº/, /„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„É¨„Éì„É•„Éº/, /ÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØ/,
        /‰ª£Á†ÅÂÆ°Êü•/, /Êû∂ÊûÑÂÆ°Êü•/, /Ë¥®ÈáèÊ£ÄÊü•/
      ],
      excludePatterns: []
    },
    'phase-9-deployment': {
      patterns: [
        /deployment/i, /CI\/CD/i, /production/i, /vercel/i, /deploy/i, /phase.?9/i,
        /Î∞∞Ìè¨/, /ÌîÑÎ°úÎçïÏÖò/, /Ïö¥ÏòÅ\s*ÌôòÍ≤Ω/,
        /„Éá„Éó„É≠„Ç§/, /Êú¨Áï™/, /ÈÅãÁî®Áí∞Â¢É/,
        /ÈÉ®ÁΩ≤/, /Áîü‰∫ßÁéØÂ¢É/, /ËøêÁª¥/
      ],
      excludePatterns: []
    }
  };

  for (const [skill, config] of Object.entries(implicitSkillPatterns)) {
    // Check exclude patterns first
    const excluded = config.excludePatterns.some(pattern => pattern.test(msg));
    if (excluded) continue;

    for (const pattern of config.patterns) {
      if (pattern.test(msg)) {
        return {
          skill,
          confidence: 0.8,
          pattern: pattern.toString()
        };
      }
    }
  }

  return null;
}

// ============================================================
// 14. v1.4.0 Ambiguity Detection Functions
// ============================================================

/**
 * Check if text contains file path or extension
 * @param {string} text - Input text
 * @returns {boolean}
 */
function containsFilePath(text) {
  if (!text) return false;
  const patterns = [
    /\.(js|ts|tsx|jsx|py|go|rs|java|cpp|c|h|md|json|yaml|yml|css|scss|html)(\s|$)/i,
    /(src|lib|scripts|hooks|docs|tests?|spec|components?|pages?)\//i,
    /[A-Za-z]:\\|\/[A-Za-z]+\//  // Windows/Unix absolute paths
  ];
  return patterns.some(p => p.test(text));
}

/**
 * Check if text contains technical terms
 * @param {string} text - Input text
 * @returns {boolean}
 */
function containsTechnicalTerms(text) {
  if (!text) return false;
  const technicalTerms = [
    /function\s+\w+/i, /class\s+\w+/i, /interface\s+\w+/i, /const\s+\w+/i,
    /useState|useEffect|component|module|import|export/i,
    /REST|GraphQL|endpoint|API|HTTP|GET|POST|PUT|DELETE/i,
    /SELECT|INSERT|UPDATE|DELETE|JOIN|WHERE/i,
    /PDCA|gap-detector|pdca-iterator|pipeline/i,
    /npm|yarn|pnpm|pip|cargo|go mod/i
  ];
  return technicalTerms.some(p => p.test(text));
}

/**
 * Check if text has specific nouns (not vague)
 * @param {string} text - Input text
 * @returns {boolean}
 */
function hasSpecificNouns(text) {
  if (!text) return false;
  // Vague pronouns that indicate ambiguity
  const vaguePronouns = /\b(it|this|that|something|thing|stuff|Ïù¥Í±∞|Ï†ÄÍ±∞|Í∑∏Í±∞|„Åì„Çå|„Åù„Çå|„ÅÇ„Çå|Ëøô‰∏™|ÈÇ£‰∏™)\b/i;
  return !vaguePronouns.test(text) || text.length > 30;
}

/**
 * Check if text has scope definition
 * @param {string} text - Input text
 * @returns {boolean}
 */
function hasScopeDefinition(text) {
  if (!text) return false;
  const scopeIndicators = [
    /\b(only|just|simple|basic|full|complete|all|entire|minimal|minimum)\b/i,
    /\b(Ìïú|Ï†ÑÏ≤¥|Î™®Îì†|Í∞ÑÎã®|Í∏∞Î≥∏|ÏµúÏÜå)\b/,
    /\b(„Å†„Åë|ÂÖ®ÈÉ®|ÂÖ®„Å¶|Á∞°Âçò|Âü∫Êú¨)\b/,
    /\b(Âè™|ÂÖ®ÈÉ®|ÊâÄÊúâ|ÁÆÄÂçï|Âü∫Êú¨)\b/
  ];
  return scopeIndicators.some(p => p.test(text));
}

/**
 * Check for multiple interpretations
 * @param {string} text - Input text
 * @returns {boolean}
 */
function hasMultipleInterpretations(text) {
  if (!text) return false;
  // Words that could mean many things
  const ambiguousWords = /\b(better|good|nice|improve|update|change|fix|Ï¢ãÍ≤å|Í∞úÏÑ†|Î≥ÄÍ≤Ω|ÏàòÏ†ï|ËâØ„Åè|ÊîπÂñÑ|ÂèòÂ•Ω|ÊîπËøõ)\b/i;
  return ambiguousWords.test(text) && text.length < 50;
}

/**
 * Detect context conflicts
 * @param {string} request - User request
 * @param {Object} context - Current context (files, status)
 * @returns {boolean}
 */
function detectContextConflicts(request, context) {
  if (!context) return false;
  // Simple heuristic: if request mentions creating something that might exist
  const createWords = /\b(create|make|new|add|ÎßåÎì§|ÏÉùÏÑ±|Ï∂îÍ∞Ä|‰ΩúÊàê|Êñ∞„Åó„ÅÑ|ÂàõÂª∫|Êñ∞)\b/i;
  if (createWords.test(request) && context.existingFeature) {
    return true;
  }
  return false;
}

/**
 * Calculate ambiguity score for user request
 * @param {string} userRequest - User request text
 * @param {Object} context - Current context
 * @returns {Object} AmbiguityResult
 */
function calculateAmbiguityScore(userRequest, context = {}) {
  if (!userRequest || typeof userRequest !== 'string') {
    return { score: 100, factors: [{ type: 'empty_request', weight: 100 }], shouldClarify: true, bypassed: false };
  }

  // === Magic Word Bypass ===
  const bypassKeywords = ['!hotfix', '!prototype', '!bypass'];
  for (const keyword of bypassKeywords) {
    if (userRequest.includes(keyword)) {
      return {
        score: 0,
        factors: [],
        shouldClarify: false,
        bypassed: true,
        bypassReason: `Magic word "${keyword}" detected`
      };
    }
  }

  let score = 0;
  const factors = [];

  // === Addition Factors ===

  // 1. Missing specific nouns (+20)
  if (!hasSpecificNouns(userRequest)) {
    score += 20;
    factors.push({ type: 'missing_details', weight: 20, description: 'Vague pronouns used' });
  }

  // 2. Scope undefined (+20)
  if (!hasScopeDefinition(userRequest)) {
    score += 20;
    factors.push({ type: 'scope_undefined', weight: 20, description: 'Scope not specified' });
  }

  // 3. Multiple interpretations possible (+30)
  if (hasMultipleInterpretations(userRequest)) {
    score += 30;
    factors.push({ type: 'multi_interpretation', weight: 30, description: 'Request is ambiguous' });
  }

  // 4. Context conflicts (+30)
  if (detectContextConflicts(userRequest, context)) {
    score += 30;
    factors.push({ type: 'conflict_detected', weight: 30, description: 'May conflict with existing code' });
  }

  // 5. Very short request (+20)
  if (userRequest.length < 15) {
    score += 20;
    factors.push({ type: 'too_short', weight: 20, description: 'Request too brief' });
  }

  // === Deduction Factors ===

  // 6. Contains file path (-30)
  if (containsFilePath(userRequest)) {
    score -= 30;
    factors.push({ type: 'has_file_path', weight: -30, description: 'File path specified' });
  }

  // 7. Contains technical terms (-20)
  if (containsTechnicalTerms(userRequest)) {
    score -= 20;
    factors.push({ type: 'has_technical_terms', weight: -20, description: 'Technical terms used' });
  }

  // Ensure score is within 0-100
  score = Math.max(0, Math.min(100, score));

  return {
    score,
    factors,
    shouldClarify: score >= 50,
    clarifyingQuestions: score >= 50 ? generateClarifyingQuestions(userRequest, factors) : undefined,
    bypassed: false
  };
}

/**
 * Generate clarifying questions based on ambiguity factors
 * @param {string} userRequest - Original request
 * @param {Array} factors - Ambiguity factors
 * @returns {Array} ClarifyingQuestion[]
 */
function generateClarifyingQuestions(userRequest, factors) {
  const questions = [];
  const featureName = extractFeatureNameFromRequest(userRequest);

  for (const factor of factors) {
    switch (factor.type) {
      case 'scope_undefined':
        questions.push({
          question: `"${featureName || 'this feature'}"Ïùò Î≤îÏúÑÎ•º Ï†ïÌï¥Ï£ºÏÑ∏Ïöî`,
          header: 'Scope',
          options: [
            { label: 'ÏµúÏÜå Í∏∞Îä• (Í∂åÏû•)', description: 'ÌïµÏã¨ Í∏∞Îä•Îßå Îπ†Î•¥Í≤å Íµ¨ÌòÑ' },
            { label: 'Í∏∞Î≥∏ Í∏∞Îä•', description: 'ÏùºÎ∞òÏ†ÅÏù∏ Í∏∞Îä• Ìè¨Ìï®' },
            { label: 'Ï†ÑÏ≤¥ Í∏∞Îä•', description: 'Î™®Îì† Í¥ÄÎ†® Í∏∞Îä• Ìè¨Ìï®' }
          ]
        });
        break;

      case 'conflict_detected':
        questions.push({
          question: 'Í∏∞Ï°¥ ÏΩîÎìúÏôÄÏùò Í¥ÄÍ≥ÑÎ•º Ï†ïÌï¥Ï£ºÏÑ∏Ïöî',
          header: 'Conflict',
          options: [
            { label: 'ÌôïÏû•', description: 'Í∏∞Ï°¥ ÏΩîÎìú ÏúÑÏóê Ï∂îÍ∞Ä' },
            { label: 'ÍµêÏ≤¥', description: 'ÏÉà ÏΩîÎìúÎ°ú ÎåÄÏ≤¥' },
            { label: 'Î≥ÑÎèÑ ÏÉùÏÑ±', description: 'ÏÉà ÌååÏùº/Î™®ÎìàÎ°ú Î∂ÑÎ¶¨' }
          ]
        });
        break;

      case 'multi_interpretation':
        questions.push({
          question: 'Ïñ¥Îñ§ Ï¢ÖÎ•òÏùò ÏûëÏóÖÏù∏Í∞ÄÏöî?',
          header: 'Task Type',
          options: [
            { label: 'ÏÉà Í∏∞Îä•', description: 'Ï≤òÏùåÎ∂ÄÌÑ∞ ÏÉàÎ°ú ÎßåÎì§Í∏∞' },
            { label: 'ÏàòÏ†ï/Í∞úÏÑ†', description: 'Í∏∞Ï°¥ ÏΩîÎìú Î≥ÄÍ≤Ω' },
            { label: 'Î≤ÑÍ∑∏ ÏàòÏ†ï', description: 'Î¨∏Ï†ú Ìï¥Í≤∞' }
          ]
        });
        break;

      case 'missing_details':
        questions.push({
          question: 'Îçî Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏÑ§Î™ÖÌï¥ Ï£ºÏÑ∏Ïöî',
          header: 'Details',
          options: [
            { label: 'ÏûêÏÑ∏Ìûà ÏÑ§Î™Ö', description: 'Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ï†úÍ≥µ' },
            { label: 'AIÍ∞Ä ÌåêÎã®', description: 'Ïª®ÌÖçÏä§Ìä∏ Í∏∞Î∞ò ÏûêÎèô Í≤∞Ï†ï' }
          ]
        });
        break;
    }
  }

  return questions.slice(0, 4); // Max 4 questions
}

/**
 * Extract feature name from user request
 * @param {string} request - User request
 * @returns {string} Feature name or empty string
 */
function extractFeatureNameFromRequest(request) {
  if (!request) return '';

  // Try to extract feature name using various patterns
  const patterns = [
    /(?:create|implement|add|build|make|develop)\s+(?:a\s+)?([a-z][a-z0-9-]*)/i,
    /([Í∞Ä-Ìû£]+)\s*(?:Í∏∞Îä•|feature)/i,
    /(.+?)\s*(?:ÎßåÎì§|Íµ¨ÌòÑ|Ï∂îÍ∞Ä)/i
  ];

  for (const pattern of patterns) {
    const match = request.match(pattern);
    if (match && match[1] && match[1].length > 1) {
      return match[1].toLowerCase().trim();
    }
  }

  return '';
}

// ============================================================
// 15. v1.4.0 PDCA Automation Functions
// ============================================================

/**
 * Determine if PDCA should auto-start
 * @param {string} feature - Feature name
 * @param {string} taskClassification - Task classification
 * @returns {boolean}
 */
function shouldAutoStartPdca(feature, taskClassification) {
  // Quick Fix ‚Üí No auto-start
  if (taskClassification === 'quick_fix') return false;

  // Minor Change ‚Üí Optional based on config
  if (taskClassification === 'minor_change') {
    return getConfig('pdca.requireDesignDoc', false);
  }

  // Feature, Major Feature ‚Üí Strongly recommended (true)
  return true;
}

/**
 * Auto advance PDCA phase
 * @param {string} feature - Feature name
 * @param {string} currentPhase - Current phase
 * @param {Object} result - Phase result (matchRate, etc.)
 * @returns {Object} { nextPhase, autoExecute, command }
 */
function autoAdvancePdcaPhase(feature, currentPhase, result = {}) {
  const matchRateThreshold = getConfig('pdca.matchRateThreshold', 90);

  const transitions = {
    'plan': { next: 'design', command: `/pdca-design ${feature}` },
    'design': { next: 'do', command: null }, // Do has no auto-command
    'do': { next: 'check', command: `/pdca-analyze ${feature}` },
    'check': {
      next: (result.matchRate || 0) >= matchRateThreshold ? 'completed' : 'act',
      command: (result.matchRate || 0) >= matchRateThreshold
        ? `/pdca-report ${feature}`
        : `/pdca-iterate ${feature}`
    },
    'act': { next: 'check', command: `/pdca-analyze ${feature}` }
  };

  const transition = transitions[currentPhase.toLowerCase()];
  if (!transition) {
    return { nextPhase: 'unknown', autoExecute: false, command: null };
  }

  return {
    nextPhase: typeof transition.next === 'function' ? transition.next() : transition.next,
    autoExecute: transition.command !== null,
    command: transition.command
  };
}

/**
 * Get Hook context (platform unified)
 * @returns {Object} HookContext
 */
function getHookContext() {
  const isGemini = isGeminiCli();

  return {
    platform: isGemini ? 'gemini' : 'claude',
    toolName: process.env.TOOL_NAME || 'unknown',
    toolInput: isGemini
      ? safeJsonParse(process.env.TOOL_INPUT, {})
      : safeJsonParse(process.env.TOOL_PARAMS, {}),
    filePath: process.env.FILE_PATH || '',
    sessionId: process.env.SESSION_ID || '',
    projectDir: PROJECT_DIR
  };
}

/**
 * Emit AskUserQuestion payload (platform unified)
 * @param {Object} options - Question options
 * @returns {string} Formatted output
 */
function emitUserPrompt(options) {
  const isGemini = isGeminiCli();

  const payload = {
    type: 'ask_user',
    questions: options.questions || [{
      question: options.question,
      header: options.header || 'Question',
      options: options.options || [],
      multiSelect: options.multiSelect || false
    }]
  };

  if (isGemini) {
    // Gemini CLI: JSON to stdout
    return JSON.stringify(payload);
  } else {
    // Claude Code: Formatted text with recommendations
    return formatAskUserQuestion(payload);
  }
}

/**
 * Format AskUserQuestion for Claude Code
 * @param {Object} payload - Question payload
 * @returns {string} Formatted text
 */
function formatAskUserQuestion(payload) {
  let output = '';
  for (const q of payload.questions) {
    output += `\n‚ùì **${q.header}**: ${q.question}\n`;
    if (q.options && q.options.length > 0) {
      q.options.forEach((opt, idx) => {
        const prefix = idx === 0 && opt.label.includes('Í∂åÏû•') ? '‚Üí ' : '  ';
        output += `${prefix}${idx + 1}. **${opt.label}**: ${opt.description}\n`;
      });
    }
  }
  return output.trim();
}

/**
 * Safe JSON parse with fallback
 * @param {string} str - JSON string
 * @param {*} fallback - Fallback value
 * @returns {*} Parsed value or fallback
 */
function safeJsonParse(str, fallback = null) {
  try {
    return str ? JSON.parse(str) : fallback;
  } catch (e) {
    return fallback;
  }
}

/**
 * Get bkit configuration with caching and environment variable overrides
 * v1.4.0 P4: Enhanced with caching and env var support
 *
 * Environment variable override format:
 * - BKIT_PDCA_THRESHOLD ‚Üí pdca.matchRateThreshold
 * - BKIT_PDCA_MAX_ITERATIONS ‚Üí pdca.maxIterations
 * - BKIT_PDCA_AUTO_ITERATE ‚Üí pdca.autoIterate
 * - BKIT_TRIGGER_ENABLED ‚Üí triggers.implicitEnabled
 * - BKIT_PIPELINE_AUTO ‚Üí pipeline.autoTransition
 *
 * @param {boolean} forceRefresh - Force cache refresh
 * @returns {Object} Configuration object
 */
function getBkitConfig(forceRefresh = false) {
  // Check cache first (10 second TTL for config)
  if (!forceRefresh) {
    const cached = _cache.get('bkit-config', 10000);
    if (cached) return cached;
  }

  // Build configuration with environment variable overrides
  const config = {
    pdca: {
      matchRateThreshold: parseInt(process.env.BKIT_PDCA_THRESHOLD, 10) ||
        getConfig('pdca.matchRateThreshold', 90),
      maxIterations: parseInt(process.env.BKIT_PDCA_MAX_ITERATIONS, 10) ||
        getConfig('pdca.maxIterations', 5),
      autoIterate: process.env.BKIT_PDCA_AUTO_ITERATE !== undefined
        ? process.env.BKIT_PDCA_AUTO_ITERATE === 'true'
        : getConfig('pdca.autoIterate', true),
      requireDesignDoc: process.env.BKIT_PDCA_REQUIRE_DESIGN !== undefined
        ? process.env.BKIT_PDCA_REQUIRE_DESIGN === 'true'
        : getConfig('pdca.requireDesignDoc', true)
    },
    triggers: {
      implicitEnabled: process.env.BKIT_TRIGGER_ENABLED !== undefined
        ? process.env.BKIT_TRIGGER_ENABLED === 'true'
        : getConfig('triggers.implicitEnabled', true),
      confidenceThreshold: parseFloat(process.env.BKIT_TRIGGER_CONFIDENCE) ||
        getConfig('triggers.confidenceThreshold', 0.8),
      clarifyAmbiguity: process.env.BKIT_TRIGGER_CLARIFY !== undefined
        ? process.env.BKIT_TRIGGER_CLARIFY === 'true'
        : getConfig('triggers.clarifyAmbiguity', true)
    },
    pipeline: {
      autoTransition: process.env.BKIT_PIPELINE_AUTO !== undefined
        ? process.env.BKIT_PIPELINE_AUTO === 'true'
        : getConfig('pipeline.autoTransition', true),
      skipConfirmation: process.env.BKIT_PIPELINE_SKIP_CONFIRM !== undefined
        ? process.env.BKIT_PIPELINE_SKIP_CONFIRM === 'true'
        : getConfig('pipeline.skipConfirmation', false)
    },
    // v1.4.0 P4: Additional configuration sections
    multiFeature: {
      maxActiveFeatures: parseInt(process.env.BKIT_MAX_FEATURES, 10) ||
        getConfig('multiFeature.maxActiveFeatures', 5),
      autoSwitch: process.env.BKIT_AUTO_SWITCH !== undefined
        ? process.env.BKIT_AUTO_SWITCH === 'true'
        : getConfig('multiFeature.autoSwitch', true)
    },
    cache: {
      enabled: process.env.BKIT_CACHE_ENABLED !== undefined
        ? process.env.BKIT_CACHE_ENABLED === 'true'
        : getConfig('cache.enabled', true),
      ttl: parseInt(process.env.BKIT_CACHE_TTL, 10) ||
        getConfig('cache.ttl', 5000)
    }
  };

  // Cache the result
  _cache.set('bkit-config', config);

  return config;
}

// ============================================================
// 16. Requirement Fulfillment Functions (v1.4.0 - P2)
// ============================================================

/**
 * Extract requirements from Plan document
 * @param {string} planDocPath - Path to plan document
 * @returns {Array<{id: string, text: string, priority: string}>}
 */
function extractRequirementsFromPlan(planDocPath) {
  const requirements = [];

  try {
    const fullPath = path.isAbsolute(planDocPath)
      ? planDocPath
      : path.join(PROJECT_DIR, planDocPath);

    if (!fs.existsSync(fullPath)) {
      debugLog('RequirementTracer', 'Plan doc not found', { path: fullPath });
      return requirements;
    }

    const content = fs.readFileSync(fullPath, 'utf8');

    // Pattern 1: Markdown table with ID column
    const tablePattern = /\|\s*(FR-\d+|REQ-\d+|P\d+-\d+)\s*\|\s*([^|]+)\s*\|\s*(High|Medium|Low|Critical)?\s*\|/gi;
    let match;
    while ((match = tablePattern.exec(content)) !== null) {
      requirements.push({
        id: match[1].trim(),
        text: match[2].trim(),
        priority: match[3]?.trim() || 'Medium'
      });
    }

    // Pattern 2: List items with IDs
    const listPattern = /[-*]\s*\[(FR-\d+|REQ-\d+|P\d+-\d+)\]\s*(.+)/gi;
    while ((match = listPattern.exec(content)) !== null) {
      const id = match[1].trim();
      if (!requirements.find(r => r.id === id)) {
        requirements.push({
          id: id,
          text: match[2].trim(),
          priority: 'Medium'
        });
      }
    }

    // Pattern 3: Checkbox items
    const checkboxPattern = /[-*]\s*\[[ x]\]\s*(?:lib\/|scripts\/|hooks\/)?([^:]+):\s*`?(\w+)\(`?\)?/gi;
    while ((match = checkboxPattern.exec(content)) !== null) {
      const id = `IMPL-${String(requirements.length + 1).padStart(3, '0')}`;
      requirements.push({
        id: id,
        text: `${match[1]}: ${match[2]}()`,
        priority: 'High'
      });
    }

    debugLog('RequirementTracer', 'Requirements extracted', {
      path: fullPath,
      count: requirements.length
    });

  } catch (error) {
    debugLog('RequirementTracer', 'Error extracting requirements', { error: error.message });
  }

  return requirements;
}

/**
 * Calculate requirement fulfillment rate
 * @param {string} planDocPath - Path to plan document
 * @param {Object} implementationAnalysis - Analysis results from code
 * @returns {{ overall: number, requirements: Array, gaps: Array }}
 */
function calculateRequirementFulfillment(planDocPath, implementationAnalysis = {}) {
  const requirements = extractRequirementsFromPlan(planDocPath);

  if (requirements.length === 0) {
    return { overall: 0, requirements: [], gaps: ['No requirements found in plan document'] };
  }

  const results = [];
  const implementedFunctions = implementationAnalysis.functions || [];
  const implementedFiles = implementationAnalysis.files || [];

  for (const req of requirements) {
    let status = 'missing';
    let score = 0;

    const funcMatch = req.text.match(/`?(\w+)\(\)`?/);
    if (funcMatch) {
      const funcName = funcMatch[1];
      if (implementedFunctions.includes(funcName)) {
        status = 'fulfilled';
        score = 100;
      }
    }

    const fileMatch = req.text.match(/([\w\/.-]+\.(js|ts|tsx|jsx|py))/);
    if (fileMatch && status !== 'fulfilled') {
      const fileName = fileMatch[1];
      if (implementedFiles.some(f => f.includes(fileName))) {
        status = 'partial';
        score = 50;
      }
    }

    if (status === 'missing') {
      const keywords = req.text.toLowerCase().split(/\s+/).filter(w => w.length > 3);
      const matchCount = keywords.filter(k =>
        implementedFunctions.some(f => f.toLowerCase().includes(k)) ||
        implementedFiles.some(f => f.toLowerCase().includes(k))
      ).length;

      if (matchCount > 0) {
        score = Math.min(50, matchCount * 20);
        status = score >= 50 ? 'partial' : 'missing';
      }
    }

    results.push({ id: req.id, text: req.text, priority: req.priority, status, score });
  }

  const overall = results.length > 0
    ? Math.round(results.reduce((sum, r) => sum + r.score, 0) / results.length)
    : 0;

  const gaps = results
    .filter(r => r.status !== 'fulfilled')
    .map(r => `${r.id}: ${r.text} (${r.status})`);

  return { overall, requirements: results, gaps };
}

// ============================================================
// 17. Phase Transition Functions (v1.4.0 - P3)
// ============================================================

/**
 * Check if phase deliverables are complete
 * @param {number} phase - Phase number (1-9)
 * @param {string} feature - Feature name
 * @returns {{ complete: boolean, missing: string[], optional: string[] }}
 */
function checkPhaseDeliverables(phase, feature) {
  const deliverables = {
    1: { required: [`docs/01-plan/schema/${feature}.schema.md`], optional: [] },
    2: { required: [`docs/01-plan/conventions/${feature}.convention.md`], optional: [] },
    3: { required: [], optional: [`mockups/${feature}/`] },
    4: { required: [`docs/02-design/api/${feature}.api.md`], optional: [] },
    5: { required: [], optional: [`src/components/${feature}/`] },
    6: { required: [], optional: [`src/pages/${feature}/`] },
    7: { required: [], optional: [] },
    8: { required: [`docs/03-analysis/${feature}.analysis.md`], optional: [] },
    9: { required: [], optional: [`docs/04-report/${feature}.report.md`] }
  };

  const phaseDeliverables = deliverables[phase] || { required: [], optional: [] };
  const missing = [];
  const optionalCompleted = [];

  for (const req of phaseDeliverables.required) {
    const fullPath = path.join(PROJECT_DIR, req);
    if (!fs.existsSync(fullPath)) {
      missing.push(req);
    }
  }

  for (const opt of phaseDeliverables.optional) {
    const fullPath = path.join(PROJECT_DIR, opt);
    if (fs.existsSync(fullPath)) {
      optionalCompleted.push(opt);
    }
  }

  return { complete: missing.length === 0, missing, optional: optionalCompleted };
}

/**
 * Validate PDCA phase transition
 * @param {string} feature - Feature name
 * @param {string} fromPhase - Current phase
 * @param {string} toPhase - Target phase
 * @returns {{ valid: boolean, reason?: string, suggestion?: string }}
 */
function validatePdcaTransition(feature, fromPhase, toPhase) {
  const phaseOrder = ['plan', 'design', 'do', 'check', 'act', 'completed'];
  const fromIndex = phaseOrder.indexOf(fromPhase);
  const toIndex = phaseOrder.indexOf(toPhase);

  if (fromIndex === -1 || toIndex === -1) {
    return { valid: false, reason: `Invalid phase`, suggestion: `Valid: ${phaseOrder.join(', ')}` };
  }

  const isForward = toIndex > fromIndex;
  const isCheckActLoop = (fromPhase === 'check' && toPhase === 'act') ||
    (fromPhase === 'act' && toPhase === 'check');

  if (!isForward && !isCheckActLoop && toPhase !== 'completed') {
    return { valid: false, reason: `Cannot go from ${fromPhase} to ${toPhase}` };
  }

  if (fromPhase === 'plan' && toPhase === 'design' && !findPlanDoc(feature)) {
    return { valid: false, reason: 'Plan doc not found', suggestion: `/pdca-plan ${feature}` };
  }

  if (fromPhase === 'design' && toPhase === 'do' && !findDesignDoc(feature)) {
    return { valid: false, reason: 'Design doc not found', suggestion: `/pdca-design ${feature}` };
  }

  if (fromPhase === 'check' && toPhase === 'completed') {
    const status = getPdcaStatusFull();
    const matchRate = status.features?.[feature]?.matchRate || 0;
    if (matchRate < 90) {
      return { valid: false, reason: `Match rate ${matchRate}% < 90%`, suggestion: `/pdca-iterate ${feature}` };
    }
  }

  return { valid: true };
}

// ============================================================
// 18. Platform Compatibility (v1.4.0)
// ============================================================

/**
 * Check if running in Gemini CLI environment
 * @returns {boolean}
 */
function isGeminiCli() {
  return BKIT_PLATFORM === 'gemini';
}

/**
 * Check if running in Claude Code environment
 * @returns {boolean}
 */
function isClaudeCode() {
  return BKIT_PLATFORM === 'claude';
}

/**
 * Get platform-specific path from plugin root
 * @param {string} relativePath - Relative path from plugin root
 * @returns {string} Full path
 */
function getPluginPath(relativePath) {
  return path.join(PLUGIN_ROOT, relativePath);
}

/**
 * Get project path
 * @param {string} relativePath - Relative path from project root
 * @returns {string} Full path
 */
function getProjectPath(relativePath) {
  return path.join(PROJECT_DIR, relativePath);
}

/**
 * Get template file path
 * @param {string} templateName - Template name (plan, design, analysis, report)
 * @returns {string} Full path to template
 */
function getTemplatePath(templateName) {
  return path.join(PLUGIN_ROOT, 'templates', `${templateName}.template.md`);
}

// ============================================================
// v1.4.4: Active Skill/Agent Tracking for Unified Hooks
// GitHub Issue #9354 Workaround
// ============================================================

/**
 * Set the currently active skill in session context
 * Called when a skill is invoked
 * @param {string} skillName - Name of the skill
 */
function setActiveSkill(skillName) {
  const status = getPdcaStatusFull() || createInitialStatusV2();
  if (!status.session) status.session = {};
  status.session.lastSkill = skillName;
  status.session.lastSkillTime = new Date().toISOString();
  savePdcaStatus(status);
  debugLog('Session', 'Active skill set', { skillName });
}

/**
 * Set the currently active agent in session context
 * Called when an agent is invoked
 * @param {string} agentName - Name of the agent
 */
function setActiveAgent(agentName) {
  const status = getPdcaStatusFull() || createInitialStatusV2();
  if (!status.session) status.session = {};
  status.session.lastAgent = agentName;
  status.session.lastAgentTime = new Date().toISOString();
  savePdcaStatus(status);
  debugLog('Session', 'Active agent set', { agentName });
}

/**
 * Clear active skill/agent from session
 * Called after Stop event completes
 */
function clearActiveContext() {
  const status = getPdcaStatusFull();
  if (!status || !status.session) return;

  delete status.session.lastSkill;
  delete status.session.lastSkillTime;
  delete status.session.lastAgent;
  delete status.session.lastAgentTime;

  savePdcaStatus(status);
  debugLog('Session', 'Active context cleared');
}

/**
 * Get current active skill name
 * @returns {string|null}
 */
function getActiveSkill() {
  const status = getPdcaStatusFull();
  return status?.session?.lastSkill || null;
}

/**
 * Get current active agent name
 * @returns {string|null}
 */
function getActiveAgent() {
  const status = getPdcaStatusFull();
  return status?.session?.lastAgent || null;
}

// ============================================================
// Exports
// ============================================================

module.exports = {
  // Configuration
  getConfig,
  getConfigArray,
  loadConfig,

  // File Detection
  isSourceFile,
  isCodeFile,
  isUiFile,
  isEnvFile,

  // Tier Detection
  getLanguageTier,
  getTierDescription,
  getTierPdcaGuidance,
  isTier1,
  isTier2,
  isTier3,
  isTier4,
  isExperimentalTier,

  // Feature Detection
  extractFeature,

  // PDCA Document Detection
  findDesignDoc,
  findPlanDoc,

  // Task Classification
  classifyTask,
  classifyTaskByLines,
  getPdcaLevel,
  getPdcaGuidance,
  getPdcaGuidanceByLevel,

  // JSON Output
  outputAllow,
  outputBlock,
  outputEmpty,
  truncateContext,
  xmlSafeOutput,
  MAX_CONTEXT_LENGTH,

  // Level Detection
  detectLevel,

  // Input Helpers
  readStdin,
  readStdinSync,
  parseHookInput,

  // Constants
  PLUGIN_ROOT,
  PROJECT_DIR,
  TIER_EXTENSIONS,
  DEFAULT_EXCLUDE_PATTERNS,
  DEFAULT_FEATURE_PATTERNS,

  // Task System Integration (v1.3.1 - FR-01~05, v1.4.2 - FR-06, v1.4.4 - FR-07/11)
  PDCA_PHASES,
  getPdcaTaskMetadata,
  generatePdcaTaskSubject,
  generatePdcaTaskDescription,
  generateTaskGuidance,
  getPreviousPdcaPhase,
  findPdcaStatus,
  getCurrentPdcaPhase,
  autoCreatePdcaTask,
  // v1.4.4 FR-11: Level Phase Map
  LEVEL_PHASE_MAP,
  canSkipPhase,
  getRequiredPhases,
  getNextPhaseForLevel,
  isPhaseApplicable,
  getLevelPhaseGuide,
  updatePdcaTaskStatus,
  // v1.4.7 Task ID Persistence (FR-02, FR-03, FR-07)
  savePdcaTaskId,
  getPdcaTaskId,
  // v1.4.7 Task Chain (FR-01, FR-12)
  createPdcaTaskChain,
  getTaskChainStatus,
  // v1.4.7 Check‚ÜîAct Iteration (FR-04, FR-05, FR-06)
  triggerNextPdcaAction,
  // v1.4.7 Full-Auto Mode (Section 11)
  getAutomationLevel,
  isFullAutoMode,
  shouldAutoAdvance,
  generateAutoTrigger,

  // Platform Compatibility (v1.4.0)
  BKIT_PLATFORM,
  BKIT_PROJECT_DIR,
  detectPlatform,
  isGeminiCli,
  isClaudeCode,
  getPluginPath,
  getProjectPath,
  getTemplatePath,

  // Debug Logging (v1.4.0 - Hooks Reliability)
  DEBUG_LOG_PATHS,
  debugLog,
  getDebugLogPath,

  // PDCA Status Management (v1.4.0 - Hooks Reliability)
  PDCA_STATUS_PATH,
  initPdcaStatusIfNotExists,
  getPdcaStatusFull,
  getFeatureStatus,
  updatePdcaStatus,
  addPdcaHistory,
  completePdcaFeature,
  extractFeatureFromContext,
  savePdcaStatus,
  loadPdcaStatus,

  // v1.4.0 Multi-Feature Context Management (P4)
  setActiveFeature,
  addActiveFeature,
  removeActiveFeature,
  getActiveFeatures,
  switchFeatureContext,

  // v1.4.0 Intent Detection (8-Language Support)
  detectNewFeatureIntent,
  matchImplicitAgentTrigger,
  matchImplicitSkillTrigger,

  // v1.4.0 Ambiguity Detection
  containsFilePath,
  containsTechnicalTerms,
  hasSpecificNouns,
  hasScopeDefinition,
  hasMultipleInterpretations,
  detectContextConflicts,
  calculateAmbiguityScore,
  generateClarifyingQuestions,
  extractFeatureNameFromRequest,

  // v1.4.0 PDCA Automation
  shouldAutoStartPdca,
  autoAdvancePdcaPhase,
  getHookContext,
  emitUserPrompt,
  formatAskUserQuestion,
  safeJsonParse,
  getBkitConfig,

  // v1.4.0 Requirement Fulfillment (P2)
  extractRequirementsFromPlan,
  calculateRequirementFulfillment,

  // v1.4.0 Phase Transition (P3)
  checkPhaseDeliverables,
  validatePdcaTransition,

  // v1.4.4: Active Skill/Agent Tracking (GitHub #9354 Workaround)
  setActiveSkill,
  setActiveAgent,
  clearActiveContext,
  getActiveSkill,
  getActiveAgent
};
